//! Strategy trait and common implementations.

use crate::bar::Bar;
use crate::indicators::{
    aroon, atr, bollinger_bands, cci, darvas_boxes, dmi, donchian_channel, ema_close, heikin_ashi,
    ichimoku, keltner_channel, macd, opening_range, parabolic_sar, range_breakout_levels, roc,
    rolling_max_close, rsi, sma_close, sma_volume, starc_bands, stochastic, supertrend, williams_r,
    BollingerBands, DarvasBox, HABar, MACDEntryMode, MAType, OpeningPeriod,
};

/// Position state in a backtest.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Position {
    /// No position
    Flat,
    /// Long position (positive quantity)
    Long,
    /// Short position (negative quantity)
    Short,
}

/// Trading mode for strategies.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum TradingMode {
    /// Only generate long signals (default for backwards compatibility)
    #[default]
    LongOnly,
    /// Only generate short signals
    ShortOnly,
    /// Generate both long and short signals (bidirectional)
    LongShort,
}

/// Signal generated by a strategy.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Signal {
    /// No action
    Hold,
    /// Enter long position (from flat)
    EnterLong,
    /// Add to existing long position (pyramid)
    AddLong,
    /// Exit long position (to flat)
    ExitLong,
    /// Enter short position (from flat)
    EnterShort,
    /// Add to existing short position (pyramid)
    AddShort,
    /// Exit short position (to flat)
    ExitShort,
}

impl Signal {
    /// Returns true if this is an entry signal (EnterLong or EnterShort).
    pub fn is_entry(&self) -> bool {
        matches!(self, Signal::EnterLong | Signal::EnterShort)
    }

    /// Returns true if this is an exit signal (ExitLong or ExitShort).
    pub fn is_exit(&self) -> bool {
        matches!(self, Signal::ExitLong | Signal::ExitShort)
    }

    /// Returns true if this is an add/pyramid signal.
    pub fn is_add(&self) -> bool {
        matches!(self, Signal::AddLong | Signal::AddShort)
    }

    /// Returns true if this is a long-side signal.
    pub fn is_long_side(&self) -> bool {
        matches!(self, Signal::EnterLong | Signal::AddLong | Signal::ExitLong)
    }

    /// Returns true if this is a short-side signal.
    pub fn is_short_side(&self) -> bool {
        matches!(
            self,
            Signal::EnterShort | Signal::AddShort | Signal::ExitShort
        )
    }
}

/// Donchian breakout strategy.
///
/// Entry: Close breaks above the N-day high (upper Donchian channel)
/// Exit: Close breaks below the M-day low (lower Donchian channel, typically M < N)
///
/// This follows the Turtle trading system convention:
/// - System 1: 20-day entry, 10-day exit
/// - System 2: 55-day entry, 20-day exit
#[derive(Debug, Clone)]
pub struct DonchianBreakoutStrategy {
    entry_lookback: usize,
    exit_lookback: usize,
}

impl DonchianBreakoutStrategy {
    pub fn new(entry_lookback: usize, exit_lookback: usize) -> Self {
        Self {
            entry_lookback,
            exit_lookback,
        }
    }

    /// Turtle System 1: 20-day entry, 10-day exit
    pub fn turtle_system_1() -> Self {
        Self::new(20, 10)
    }

    /// Turtle System 2: 55-day entry, 20-day exit
    pub fn turtle_system_2() -> Self {
        Self::new(55, 20)
    }

    /// Get the entry lookback period.
    pub fn entry_lookback(&self) -> usize {
        self.entry_lookback
    }

    /// Get the exit lookback period.
    pub fn exit_lookback(&self) -> usize {
        self.exit_lookback
    }
}

impl Strategy for DonchianBreakoutStrategy {
    fn id(&self) -> &str {
        "donchian_breakout"
    }

    fn warmup_period(&self) -> usize {
        self.entry_lookback.max(self.exit_lookback)
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let current_close = bars[current_idx].close;

        match current_position {
            Position::Flat => {
                // Check for entry: close > upper channel
                let entry_channel = donchian_channel(bars, self.entry_lookback);
                if let Some(ch) = entry_channel[current_idx] {
                    if current_close > ch.upper {
                        return Signal::EnterLong;
                    }
                }
                Signal::Hold
            }
            Position::Long => {
                // Check for exit: close < lower channel
                let exit_channel = donchian_channel(bars, self.exit_lookback);
                if let Some(ch) = exit_channel[current_idx] {
                    if current_close < ch.lower {
                        return Signal::ExitLong;
                    }
                }
                Signal::Hold
            }
            Position::Short => {
                // Short exit: close > upper channel (cover on breakout)
                // For now, default to Hold (long-only mode)
                // TODO: Implement in Phase 4 when TradingMode is added to strategy
                Signal::Hold
            }
        }
    }

    fn reset(&mut self) {}
}

/// Moving Average Crossover strategy.
///
/// Entry: Fast MA crosses above slow MA (golden cross)
/// Exit: Fast MA crosses below slow MA (death cross)
///
/// Common configurations:
/// - SMA 50/200: Classic "golden cross / death cross"
/// - EMA 12/26: MACD-style short-term crossover
/// - SMA 10/50: Medium-term trend following
#[derive(Debug, Clone)]
pub struct MACrossoverStrategy {
    fast_period: usize,
    slow_period: usize,
    ma_type: MAType,
    /// Tracks whether fast was above slow on previous bar (for crossover detection)
    prev_fast_above_slow: Option<bool>,
}

impl MACrossoverStrategy {
    pub fn new(fast_period: usize, slow_period: usize, ma_type: MAType) -> Self {
        assert!(
            fast_period < slow_period,
            "Fast period must be less than slow period"
        );
        Self {
            fast_period,
            slow_period,
            ma_type,
            prev_fast_above_slow: None,
        }
    }

    /// Classic golden cross: SMA 50/200
    pub fn golden_cross_50_200() -> Self {
        Self::new(50, 200, MAType::SMA)
    }

    /// MACD-style crossover: EMA 12/26
    pub fn macd_style_12_26() -> Self {
        Self::new(12, 26, MAType::EMA)
    }

    /// Medium-term crossover: SMA 10/50
    pub fn medium_term_10_50() -> Self {
        Self::new(10, 50, MAType::SMA)
    }

    /// Get the fast period.
    pub fn fast_period(&self) -> usize {
        self.fast_period
    }

    /// Get the slow period.
    pub fn slow_period(&self) -> usize {
        self.slow_period
    }

    /// Get the MA type.
    pub fn ma_type(&self) -> MAType {
        self.ma_type
    }

    /// Compute fast and slow MAs for all bars.
    pub fn compute_mas(&self, bars: &[Bar]) -> (Vec<Option<f64>>, Vec<Option<f64>>) {
        match self.ma_type {
            MAType::SMA => (
                sma_close(bars, self.fast_period),
                sma_close(bars, self.slow_period),
            ),
            MAType::EMA => (
                ema_close(bars, self.fast_period),
                ema_close(bars, self.slow_period),
            ),
        }
    }
}

impl Strategy for MACrossoverStrategy {
    fn id(&self) -> &str {
        "ma_crossover"
    }

    fn warmup_period(&self) -> usize {
        // Need slow_period bars before we can compute the slow MA
        self.slow_period
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let (fast_ma, slow_ma) = self.compute_mas(bars);

        // Get current and previous MA values
        let current_fast = match fast_ma[current_idx] {
            Some(v) => v,
            None => return Signal::Hold,
        };
        let current_slow = match slow_ma[current_idx] {
            Some(v) => v,
            None => return Signal::Hold,
        };

        // Need previous bar to detect crossover
        if current_idx == 0 {
            return Signal::Hold;
        }

        let prev_fast = match fast_ma[current_idx - 1] {
            Some(v) => v,
            None => return Signal::Hold,
        };
        let prev_slow = match slow_ma[current_idx - 1] {
            Some(v) => v,
            None => return Signal::Hold,
        };

        let fast_above_slow = current_fast > current_slow;
        let prev_fast_above_slow = prev_fast > prev_slow;

        match current_position {
            Position::Flat => {
                // Golden cross: fast crosses above slow
                if fast_above_slow && !prev_fast_above_slow {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Death cross: fast crosses below slow
                if !fast_above_slow && prev_fast_above_slow {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => {
                // Short exit: golden cross (fast crosses above slow)
                // For now, default to Hold (long-only mode)
                // TODO: Implement in Phase 4 when TradingMode is added to strategy
                Signal::Hold
            }
        }
    }

    fn reset(&mut self) {
        self.prev_fast_above_slow = None;
    }
}

/// Time-Series Momentum (TSMOM) strategy.
///
/// Entry: When N-period return is positive (close > close N bars ago)
/// Exit: When N-period return is negative (close < close N bars ago)
///
/// This is a pure time-series momentum strategy based on academic research
/// (Moskowitz, Ooi, Pedersen 2012). It captures the well-documented momentum
/// effect where assets that have been rising tend to continue rising.
///
/// Common lookback periods:
/// - 252 days (12-month): Academic standard
/// - 126 days (6-month): Short-term momentum
/// - 21 days (1-month): Very short-term
#[derive(Debug, Clone)]
pub struct TsmomStrategy {
    lookback: usize,
}

impl TsmomStrategy {
    pub fn new(lookback: usize) -> Self {
        assert!(lookback > 0, "Lookback must be at least 1");
        Self { lookback }
    }

    /// Standard 12-month momentum (252 trading days)
    pub fn twelve_month() -> Self {
        Self::new(252)
    }

    /// 6-month momentum (126 trading days)
    pub fn six_month() -> Self {
        Self::new(126)
    }

    /// 1-month momentum (21 trading days)
    pub fn one_month() -> Self {
        Self::new(21)
    }

    /// Get the lookback period.
    pub fn lookback(&self) -> usize {
        self.lookback
    }

    /// Compute momentum (simple return) for a given index.
    /// Returns None if the lookback period hasn't elapsed.
    pub fn compute_momentum(&self, bars: &[Bar], current_idx: usize) -> Option<f64> {
        if current_idx < self.lookback {
            return None;
        }
        let lookback_idx = current_idx - self.lookback;
        let current_close = bars[current_idx].close;
        let lookback_close = bars[lookback_idx].close;
        if lookback_close == 0.0 {
            return None;
        }
        Some((current_close - lookback_close) / lookback_close)
    }
}

impl Strategy for TsmomStrategy {
    fn id(&self) -> &str {
        "tsmom"
    }

    fn warmup_period(&self) -> usize {
        self.lookback
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let current_close = bars[current_idx].close;
        let lookback_close = bars[current_idx - self.lookback].close;

        match current_position {
            Position::Flat => {
                // Entry: momentum is positive (current > lookback)
                if current_close > lookback_close {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: momentum turns negative (current < lookback)
                if current_close < lookback_close {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => {
                // Short exit: momentum turns positive (cover when trend reverses)
                // For now, default to Hold (long-only mode)
                // TODO: Implement in Phase 4 when TradingMode is added to strategy
                Signal::Hold
            }
        }
    }

    fn reset(&mut self) {}
}

/// Trait for trend-following strategies.
///
/// Strategies compute signals based on historical bar data.
/// The signal at bar T can only use data from bars 0..=T (no lookahead).
pub trait Strategy: Send + Sync {
    /// Returns the strategy's unique identifier.
    fn id(&self) -> &str;

    /// Returns the minimum number of bars required before generating signals.
    fn warmup_period(&self) -> usize;

    /// Compute signal for the current bar.
    ///
    /// # Arguments
    /// * `bars` - Historical bars up to and including current bar
    /// * `current_position` - Current position state
    ///
    /// # Returns
    /// Signal indicating what action to take
    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal;

    /// Reset internal state (for running multiple backtests).
    fn reset(&mut self);
}

/// Placeholder strategy that never trades.
#[derive(Debug, Default)]
pub struct NullStrategy;

impl Strategy for NullStrategy {
    fn id(&self) -> &str {
        "null"
    }

    fn warmup_period(&self) -> usize {
        0
    }

    fn signal(&self, _bars: &[Bar], _current_position: Position) -> Signal {
        Signal::Hold
    }

    fn reset(&mut self) {}
}

// =============================================================================
// Phase 1: ATR-Based Channel Strategies
// =============================================================================

/// Keltner Channel Breakout strategy.
///
/// Entry: Close breaks above EMA + k * ATR (upper band)
/// Exit: Close breaks below EMA - k * ATR (lower band) OR below EMA
///
/// Keltner Channels use volatility (ATR) to set dynamic bands around an EMA.
/// Unlike Bollinger Bands (which use standard deviation), Keltner uses ATR
/// which can capture intraday volatility better.
///
/// Common configurations:
/// - EMA 20, ATR 10, Mult 2.0: Standard
/// - EMA 20, ATR 20, Mult 1.5: Tighter bands for more signals
#[derive(Debug, Clone)]
pub struct KeltnerBreakoutStrategy {
    /// Period for EMA center line
    ema_period: usize,
    /// Period for ATR calculation
    atr_period: usize,
    /// Multiplier for ATR to set band width
    multiplier: f64,
}

impl KeltnerBreakoutStrategy {
    pub fn new(ema_period: usize, atr_period: usize, multiplier: f64) -> Self {
        assert!(ema_period > 0, "EMA period must be at least 1");
        assert!(atr_period > 0, "ATR period must be at least 1");
        assert!(multiplier > 0.0, "Multiplier must be positive");

        Self {
            ema_period,
            atr_period,
            multiplier,
        }
    }

    /// Standard configuration: EMA 20, ATR 10, Mult 2.0
    pub fn standard() -> Self {
        Self::new(20, 10, 2.0)
    }

    /// Tighter bands: EMA 20, ATR 20, Mult 1.5
    pub fn tight() -> Self {
        Self::new(20, 20, 1.5)
    }

    /// Get the EMA period.
    pub fn ema_period(&self) -> usize {
        self.ema_period
    }

    /// Get the ATR period.
    pub fn atr_period(&self) -> usize {
        self.atr_period
    }

    /// Get the multiplier.
    pub fn multiplier(&self) -> f64 {
        self.multiplier
    }
}

impl Strategy for KeltnerBreakoutStrategy {
    fn id(&self) -> &str {
        "keltner_breakout"
    }

    fn warmup_period(&self) -> usize {
        self.ema_period.max(self.atr_period)
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let keltner = keltner_channel(bars, self.ema_period, self.atr_period, self.multiplier);
        let current_close = bars[current_idx].close;

        let kc = match keltner[current_idx] {
            Some(k) => k,
            None => return Signal::Hold,
        };

        match current_position {
            Position::Flat => {
                // Entry: close > upper band
                if current_close > kc.upper {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: close < lower band OR close < center (EMA)
                if current_close < kc.lower || current_close < kc.center {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {}
}

/// STARC Bands Breakout strategy.
///
/// Entry: Close breaks above SMA + k * ATR (upper band)
/// Exit: Close breaks below SMA - k * ATR (lower band)
///
/// STARC (Stoller Average Range Channel) is similar to Keltner but uses
/// SMA instead of EMA for the center line, making it less responsive
/// but potentially more stable.
///
/// Common configurations:
/// - SMA 20, ATR 15, Mult 2.0: Standard
/// - SMA 10, ATR 10, Mult 1.5: More responsive
#[derive(Debug, Clone)]
pub struct STARCBreakoutStrategy {
    /// Period for SMA center line
    sma_period: usize,
    /// Period for ATR calculation
    atr_period: usize,
    /// Multiplier for ATR to set band width
    multiplier: f64,
}

impl STARCBreakoutStrategy {
    pub fn new(sma_period: usize, atr_period: usize, multiplier: f64) -> Self {
        assert!(sma_period > 0, "SMA period must be at least 1");
        assert!(atr_period > 0, "ATR period must be at least 1");
        assert!(multiplier > 0.0, "Multiplier must be positive");

        Self {
            sma_period,
            atr_period,
            multiplier,
        }
    }

    /// Standard configuration: SMA 20, ATR 15, Mult 2.0
    pub fn standard() -> Self {
        Self::new(20, 15, 2.0)
    }

    /// Responsive configuration: SMA 10, ATR 10, Mult 1.5
    pub fn responsive() -> Self {
        Self::new(10, 10, 1.5)
    }

    /// Get the SMA period.
    pub fn sma_period(&self) -> usize {
        self.sma_period
    }

    /// Get the ATR period.
    pub fn atr_period(&self) -> usize {
        self.atr_period
    }

    /// Get the multiplier.
    pub fn multiplier(&self) -> f64 {
        self.multiplier
    }
}

impl Strategy for STARCBreakoutStrategy {
    fn id(&self) -> &str {
        "starc_breakout"
    }

    fn warmup_period(&self) -> usize {
        self.sma_period.max(self.atr_period)
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let starc = starc_bands(bars, self.sma_period, self.atr_period, self.multiplier);
        let current_close = bars[current_idx].close;

        let sb = match starc[current_idx] {
            Some(s) => s,
            None => return Signal::Hold,
        };

        match current_position {
            Position::Flat => {
                // Entry: close > upper band
                if current_close > sb.upper {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: close < lower band
                if current_close < sb.lower {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {}
}

/// Supertrend strategy.
///
/// Entry: Supertrend flips to uptrend (price crosses above lower band)
/// Exit: Supertrend flips to downtrend (price crosses below upper band)
///
/// Supertrend uses ATR to create dynamic support/resistance levels.
/// In an uptrend, the lower band acts as trailing support.
/// In a downtrend, the upper band acts as trailing resistance.
///
/// Common configurations:
/// - ATR 10, Mult 3.0: Standard (less sensitive, fewer signals)
/// - ATR 10, Mult 2.0: More sensitive (more signals)
/// - ATR 7, Mult 3.0: Faster reaction
#[derive(Debug, Clone)]
pub struct SupertrendStrategy {
    /// Period for ATR calculation
    atr_period: usize,
    /// Multiplier for ATR to set band width
    multiplier: f64,
}

impl SupertrendStrategy {
    pub fn new(atr_period: usize, multiplier: f64) -> Self {
        assert!(atr_period > 0, "ATR period must be at least 1");
        assert!(multiplier > 0.0, "Multiplier must be positive");

        Self {
            atr_period,
            multiplier,
        }
    }

    /// Standard configuration: ATR 10, Mult 3.0
    pub fn standard() -> Self {
        Self::new(10, 3.0)
    }

    /// Sensitive configuration: ATR 10, Mult 2.0
    pub fn sensitive() -> Self {
        Self::new(10, 2.0)
    }

    /// Fast configuration: ATR 7, Mult 3.0
    pub fn fast() -> Self {
        Self::new(7, 3.0)
    }

    /// Get the ATR period.
    pub fn atr_period(&self) -> usize {
        self.atr_period
    }

    /// Get the multiplier.
    pub fn multiplier(&self) -> f64 {
        self.multiplier
    }
}

impl Strategy for SupertrendStrategy {
    fn id(&self) -> &str {
        "supertrend"
    }

    fn warmup_period(&self) -> usize {
        self.atr_period
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let st_values = supertrend(bars, self.atr_period, self.multiplier);

        let current_st = match st_values[current_idx] {
            Some(st) => st,
            None => return Signal::Hold,
        };

        // Need previous bar for trend flip detection
        if current_idx == 0 {
            return Signal::Hold;
        }

        let prev_st = match st_values[current_idx - 1] {
            Some(st) => st,
            None => return Signal::Hold,
        };

        match current_position {
            Position::Flat => {
                // Entry: Trend flips from downtrend to uptrend
                if current_st.is_uptrend && !prev_st.is_uptrend {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: Trend flips from uptrend to downtrend
                if !current_st.is_uptrend && prev_st.is_uptrend {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {}
}

// =============================================================================
// Supertrend Variants
// =============================================================================

/// Supertrend with Volume Filter strategy.
///
/// Only enters when volume exceeds a threshold percentage of the average volume.
/// This filters out weak breakouts that lack conviction.
///
/// Entry: Supertrend flips to uptrend AND volume > threshold * avg_volume
/// Exit: Supertrend flips to downtrend (no volume filter on exits)
#[derive(Debug, Clone)]
pub struct SupertrendVolumeStrategy {
    atr_period: usize,
    multiplier: f64,
    volume_lookback: usize,
    volume_threshold_pct: f64,
}

impl SupertrendVolumeStrategy {
    pub fn new(
        atr_period: usize,
        multiplier: f64,
        volume_lookback: usize,
        volume_threshold_pct: f64,
    ) -> Self {
        assert!(atr_period > 0, "ATR period must be at least 1");
        assert!(multiplier > 0.0, "Multiplier must be positive");
        assert!(volume_lookback > 0, "Volume lookback must be at least 1");
        assert!(
            volume_threshold_pct > 0.0,
            "Volume threshold must be positive"
        );

        Self {
            atr_period,
            multiplier,
            volume_lookback,
            volume_threshold_pct,
        }
    }
}

impl Strategy for SupertrendVolumeStrategy {
    fn id(&self) -> &str {
        "supertrend_volume"
    }

    fn warmup_period(&self) -> usize {
        self.atr_period.max(self.volume_lookback)
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let st_values = supertrend(bars, self.atr_period, self.multiplier);
        let vol_sma = sma_volume(bars, self.volume_lookback);

        let current_st = match st_values[current_idx] {
            Some(st) => st,
            None => return Signal::Hold,
        };

        if current_idx == 0 {
            return Signal::Hold;
        }

        let prev_st = match st_values[current_idx - 1] {
            Some(st) => st,
            None => return Signal::Hold,
        };

        match current_position {
            Position::Flat => {
                // Entry: Trend flips to uptrend AND volume exceeds threshold
                if current_st.is_uptrend && !prev_st.is_uptrend {
                    // Check volume filter
                    if let Some(avg_vol) = vol_sma[current_idx] {
                        let current_vol = bars[current_idx].volume;
                        if current_vol >= avg_vol * self.volume_threshold_pct {
                            return Signal::EnterLong;
                        }
                    }
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: Trend flips to downtrend (no volume filter)
                if !current_st.is_uptrend && prev_st.is_uptrend {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {}
}

/// Supertrend with Confirmation Bars strategy.
///
/// Requires N consecutive bars in the new trend before entering.
/// This filters out brief whipsaws and false breakouts.
///
/// Entry: Supertrend has been in uptrend for N bars (first flip counted)
/// Exit: Supertrend flips to downtrend
#[derive(Debug, Clone)]
pub struct SupertrendConfirmedStrategy {
    atr_period: usize,
    multiplier: f64,
    confirmation_bars: usize,
    /// Tracks consecutive uptrend bars since last entry
    uptrend_count: usize,
}

impl SupertrendConfirmedStrategy {
    pub fn new(atr_period: usize, multiplier: f64, confirmation_bars: usize) -> Self {
        assert!(atr_period > 0, "ATR period must be at least 1");
        assert!(multiplier > 0.0, "Multiplier must be positive");
        assert!(
            confirmation_bars > 0,
            "Confirmation bars must be at least 1"
        );

        Self {
            atr_period,
            multiplier,
            confirmation_bars,
            uptrend_count: 0,
        }
    }
}

impl Strategy for SupertrendConfirmedStrategy {
    fn id(&self) -> &str {
        "supertrend_confirmed"
    }

    fn warmup_period(&self) -> usize {
        self.atr_period + self.confirmation_bars
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        if current_idx < self.atr_period {
            return Signal::Hold;
        }

        let st_values = supertrend(bars, self.atr_period, self.multiplier);

        let current_st = match st_values[current_idx] {
            Some(st) => st,
            None => return Signal::Hold,
        };

        // Count consecutive uptrend bars looking backwards
        let mut uptrend_count = 0;
        for i in (0..=current_idx).rev() {
            match st_values[i] {
                Some(st) if st.is_uptrend => uptrend_count += 1,
                _ => break,
            }
        }

        match current_position {
            Position::Flat => {
                // Entry: Uptrend confirmed for N bars
                if current_st.is_uptrend && uptrend_count >= self.confirmation_bars {
                    // Only enter on the exact bar where confirmation is reached
                    if uptrend_count == self.confirmation_bars {
                        return Signal::EnterLong;
                    }
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: Trend flips to downtrend
                if !current_st.is_uptrend {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {
        self.uptrend_count = 0;
    }
}

/// Supertrend with Asymmetric Entry/Exit multipliers.
///
/// Uses different ATR multipliers for entries vs exits, allowing
/// the position more room to breathe once entered.
///
/// Entry: Price crosses above upper band (entry_multiplier)
/// Exit: Price crosses below lower band (exit_multiplier, typically larger)
#[derive(Debug, Clone)]
pub struct SupertrendAsymmetricStrategy {
    atr_period: usize,
    entry_multiplier: f64,
    exit_multiplier: f64,
}

impl SupertrendAsymmetricStrategy {
    pub fn new(atr_period: usize, entry_multiplier: f64, exit_multiplier: f64) -> Self {
        assert!(atr_period > 0, "ATR period must be at least 1");
        assert!(entry_multiplier > 0.0, "Entry multiplier must be positive");
        assert!(exit_multiplier > 0.0, "Exit multiplier must be positive");
        assert!(
            exit_multiplier >= entry_multiplier,
            "Exit multiplier should be >= entry multiplier"
        );

        Self {
            atr_period,
            entry_multiplier,
            exit_multiplier,
        }
    }
}

impl Strategy for SupertrendAsymmetricStrategy {
    fn id(&self) -> &str {
        "supertrend_asymmetric"
    }

    fn warmup_period(&self) -> usize {
        self.atr_period
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        // Calculate both entry and exit supertrend indicators
        let entry_st = supertrend(bars, self.atr_period, self.entry_multiplier);
        let exit_st = supertrend(bars, self.atr_period, self.exit_multiplier);

        let current_entry_st = match entry_st[current_idx] {
            Some(st) => st,
            None => return Signal::Hold,
        };

        let current_exit_st = match exit_st[current_idx] {
            Some(st) => st,
            None => return Signal::Hold,
        };

        if current_idx == 0 {
            return Signal::Hold;
        }

        let prev_entry_st = match entry_st[current_idx - 1] {
            Some(st) => st,
            None => return Signal::Hold,
        };

        let prev_exit_st = match exit_st[current_idx - 1] {
            Some(st) => st,
            None => return Signal::Hold,
        };

        match current_position {
            Position::Flat => {
                // Entry: Entry indicator flips to uptrend
                if current_entry_st.is_uptrend && !prev_entry_st.is_uptrend {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: Exit indicator flips to downtrend
                if !current_exit_st.is_uptrend && prev_exit_st.is_uptrend {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {}
}

/// Supertrend with Cooldown strategy.
///
/// Enforces a minimum number of bars between trades to prevent
/// whipsawing in choppy markets.
///
/// Entry: Supertrend flips to uptrend AND cooldown period has passed
/// Exit: Supertrend flips to downtrend
#[derive(Debug, Clone)]
pub struct SupertrendCooldownStrategy {
    atr_period: usize,
    multiplier: f64,
    cooldown_bars: usize,
    /// Bars since last exit
    bars_since_exit: usize,
}

impl SupertrendCooldownStrategy {
    pub fn new(atr_period: usize, multiplier: f64, cooldown_bars: usize) -> Self {
        assert!(atr_period > 0, "ATR period must be at least 1");
        assert!(multiplier > 0.0, "Multiplier must be positive");
        assert!(cooldown_bars > 0, "Cooldown bars must be at least 1");

        Self {
            atr_period,
            multiplier,
            cooldown_bars,
            bars_since_exit: usize::MAX, // Start with cooldown satisfied
        }
    }
}

impl Strategy for SupertrendCooldownStrategy {
    fn id(&self) -> &str {
        "supertrend_cooldown"
    }

    fn warmup_period(&self) -> usize {
        self.atr_period
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let st_values = supertrend(bars, self.atr_period, self.multiplier);

        let current_st = match st_values[current_idx] {
            Some(st) => st,
            None => return Signal::Hold,
        };

        if current_idx == 0 {
            return Signal::Hold;
        }

        let prev_st = match st_values[current_idx - 1] {
            Some(st) => st,
            None => return Signal::Hold,
        };

        match current_position {
            Position::Flat => {
                // Entry: Trend flips to uptrend AND cooldown satisfied
                if current_st.is_uptrend
                    && !prev_st.is_uptrend
                    && self.bars_since_exit >= self.cooldown_bars
                {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: Trend flips to downtrend
                if !current_st.is_uptrend && prev_st.is_uptrend {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {
        self.bars_since_exit = usize::MAX;
    }
}

// =============================================================================
// Phase 2: Momentum & Direction Strategies
// =============================================================================

/// DMI/ADX Directional System strategy.
///
/// Entry: +DI crosses above -DI AND ADX > threshold
/// Exit: +DI crosses below -DI OR ADX drops below threshold
///
/// Based on J. Welles Wilder's Directional Movement System.
/// ADX measures trend strength (not direction), while +DI/-DI measure direction.
///
/// Common configurations:
/// - DI Period 14, ADX Period 14, Threshold 25: Standard
/// - DI Period 20, ADX Period 20, Threshold 20: Smoother, catches longer trends
#[derive(Debug, Clone)]
pub struct DmiAdxStrategy {
    /// Period for +DI/-DI calculation
    di_period: usize,
    /// Period for ADX calculation
    adx_period: usize,
    /// Minimum ADX value for trend strength
    adx_threshold: f64,
}

impl DmiAdxStrategy {
    pub fn new(di_period: usize, adx_period: usize, adx_threshold: f64) -> Self {
        assert!(di_period > 0, "DI period must be at least 1");
        assert!(adx_period > 0, "ADX period must be at least 1");
        assert!(adx_threshold > 0.0, "ADX threshold must be positive");

        Self {
            di_period,
            adx_period,
            adx_threshold,
        }
    }

    /// Standard configuration: 14/14/25
    pub fn standard() -> Self {
        Self::new(14, 14, 25.0)
    }

    /// Smoother configuration: 20/20/20
    pub fn smoother() -> Self {
        Self::new(20, 20, 20.0)
    }

    /// Get the DI period.
    pub fn di_period(&self) -> usize {
        self.di_period
    }

    /// Get the ADX period.
    pub fn adx_period(&self) -> usize {
        self.adx_period
    }

    /// Get the ADX threshold.
    pub fn adx_threshold(&self) -> f64 {
        self.adx_threshold
    }
}

impl Strategy for DmiAdxStrategy {
    fn id(&self) -> &str {
        "dmi_adx"
    }

    fn warmup_period(&self) -> usize {
        // DMI requires double smoothing: once for DI, once for ADX
        2 * self.di_period.max(self.adx_period)
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        // Compute DMI indicators (uses di_period for all components)
        let dmi_values = dmi(bars, self.di_period);

        // Get current DMI values
        let current_dmi = match dmi_values[current_idx] {
            Some(ref d) => d,
            None => return Signal::Hold,
        };

        let plus_above_minus = current_dmi.plus_di > current_dmi.minus_di;
        let strong_trend = current_dmi.adx > self.adx_threshold;

        match current_position {
            Position::Flat => {
                // Entry: Direction is bullish and trend strength is above threshold.
                //
                // In practice, the +DI/-DI crossover often occurs *before* ADX rises above
                // the threshold; requiring both on the same bar can miss the move entirely.
                // So we enter on the first bar where both conditions are satisfied.
                if plus_above_minus && strong_trend {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: Direction turns bearish OR trend weakens.
                //
                // Similar to entry, requiring an exact crossover edge can miss the exit if the
                // cross occurs before other conditions change. Exit as soon as -DI dominates.
                if !plus_above_minus {
                    return Signal::ExitLong;
                }
                // Also exit if trend weakens below the threshold.
                if current_dmi.adx < self.adx_threshold {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {}
}

/// Aroon Cross strategy.
///
/// Entry: Aroon-Up crosses above Aroon-Down
/// Exit: Aroon-Up crosses below Aroon-Down
///
/// The Aroon indicator measures the time since the most recent high/low.
/// - Aroon-Up = 100 means we just hit a period high
/// - Aroon-Down = 100 means we just hit a period low
/// - Aroon-Up > Aroon-Down suggests bullish momentum
///
/// Common configurations:
/// - Period 25: Standard (monthly trading)
/// - Period 14: Short-term
/// - Period 50: Long-term
#[derive(Debug, Clone)]
pub struct AroonCrossStrategy {
    /// Period for Aroon calculation
    period: usize,
}

impl AroonCrossStrategy {
    pub fn new(period: usize) -> Self {
        assert!(period > 0, "Period must be at least 1");
        Self { period }
    }

    /// Standard configuration: period 25
    pub fn standard() -> Self {
        Self::new(25)
    }

    /// Short-term configuration: period 14
    pub fn short_term() -> Self {
        Self::new(14)
    }

    /// Long-term configuration: period 50
    pub fn long_term() -> Self {
        Self::new(50)
    }

    /// Get the period.
    pub fn period(&self) -> usize {
        self.period
    }
}

impl Strategy for AroonCrossStrategy {
    fn id(&self) -> &str {
        "aroon_cross"
    }

    fn warmup_period(&self) -> usize {
        self.period
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let aroon_values = aroon(bars, self.period);

        // Get current and previous Aroon values
        let current_aroon = match aroon_values[current_idx] {
            Some(ref a) => a,
            None => return Signal::Hold,
        };

        // Need previous bar for crossover detection
        if current_idx == 0 {
            return Signal::Hold;
        }

        let prev_aroon = match aroon_values[current_idx - 1] {
            Some(ref a) => a,
            None => return Signal::Hold,
        };

        let up_above_down = current_aroon.aroon_up > current_aroon.aroon_down;
        let prev_up_above_down = prev_aroon.aroon_up > prev_aroon.aroon_down;

        match current_position {
            Position::Flat => {
                // Entry: Aroon-Up crosses above Aroon-Down
                if up_above_down && !prev_up_above_down {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: Aroon-Up crosses below Aroon-Down
                if !up_above_down && prev_up_above_down {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {}
}

/// Bollinger Squeeze Breakout strategy.
///
/// Entry: When in squeeze AND close breaks above upper band
/// Exit: When close falls below middle band (SMA)
///
/// A "squeeze" occurs when volatility contracts (bandwidth narrows).
/// The breakout from a squeeze often leads to significant moves.
///
/// Common configurations:
/// - Period 20, Mult 2.0, Threshold 0.04: Standard
/// - Period 20, Mult 2.5, Threshold 0.03: Tighter squeeze detection
#[derive(Debug, Clone)]
pub struct BollingerSqueezeStrategy {
    /// Period for SMA and standard deviation
    period: usize,
    /// Standard deviation multiplier for bands
    std_mult: f64,
    /// Bandwidth threshold for squeeze detection
    squeeze_threshold: f64,
    /// Track whether we were in squeeze on previous bar
    was_in_squeeze: bool,
}

impl BollingerSqueezeStrategy {
    pub fn new(period: usize, std_mult: f64, squeeze_threshold: f64) -> Self {
        assert!(period > 0, "Period must be at least 1");
        assert!(
            std_mult > 0.0,
            "Standard deviation multiplier must be positive"
        );
        assert!(
            squeeze_threshold > 0.0,
            "Squeeze threshold must be positive"
        );

        Self {
            period,
            std_mult,
            squeeze_threshold,
            was_in_squeeze: false,
        }
    }

    /// Standard configuration: period 20, mult 2.0, threshold 0.04
    pub fn standard() -> Self {
        Self::new(20, 2.0, 0.04)
    }

    /// Tight squeeze configuration: period 20, mult 2.5, threshold 0.03
    pub fn tight_squeeze() -> Self {
        Self::new(20, 2.5, 0.03)
    }

    /// Get the period.
    pub fn period(&self) -> usize {
        self.period
    }

    /// Get the standard deviation multiplier.
    pub fn std_mult(&self) -> f64 {
        self.std_mult
    }

    /// Get the squeeze threshold.
    pub fn squeeze_threshold(&self) -> f64 {
        self.squeeze_threshold
    }

    /// Check if in squeeze (bandwidth < threshold).
    pub fn is_in_squeeze(&self, bb: &BollingerBands) -> bool {
        bb.bandwidth < self.squeeze_threshold
    }
}

impl Strategy for BollingerSqueezeStrategy {
    fn id(&self) -> &str {
        "bollinger_squeeze"
    }

    fn warmup_period(&self) -> usize {
        self.period
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let bb_values = bollinger_bands(bars, self.period, self.std_mult);

        // Get current Bollinger Bands
        let current_bb = match bb_values[current_idx] {
            Some(ref bb) => bb,
            None => return Signal::Hold,
        };

        let current_close = bars[current_idx].close;
        let in_squeeze = self.is_in_squeeze(current_bb);

        // Check previous bar squeeze state
        let prev_in_squeeze = if current_idx > 0 {
            bb_values[current_idx - 1]
                .as_ref()
                .map(|bb| self.is_in_squeeze(bb))
                .unwrap_or(false)
        } else {
            false
        };

        match current_position {
            Position::Flat => {
                // Entry: In squeeze (or was in squeeze) AND close breaks above upper band
                if (in_squeeze || prev_in_squeeze) && current_close > current_bb.upper {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: Close falls below middle band (SMA)
                if current_close < current_bb.middle {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {
        self.was_in_squeeze = false;
    }
}

// =============================================================================
// Phase 3: Price Structure Strategies
// =============================================================================

/// 52-Week High Trend strategy.
///
/// Entry: When close reaches a certain percentage of the N-period high
/// Exit: When close falls below a certain percentage of the N-period high
///
/// Based on George & Hwang (2004) "The 52-Week High and Momentum Investing"
/// which shows that stocks near their 52-week high tend to continue rising.
///
/// Common configurations:
/// - Period 252 (annual): Standard 52-week high
/// - Period 126 (semi-annual): 6-month high
/// - Entry 0.95: Buy when within 5% of high
/// - Exit 0.90: Sell when 10% below high
#[derive(Debug, Clone)]
pub struct FiftyTwoWeekHighStrategy {
    /// Lookback period for computing the rolling high
    period: usize,
    /// Entry threshold as a percentage of period high (e.g., 0.95 = 95%)
    entry_pct: f64,
    /// Exit threshold as a percentage of period high (e.g., 0.90 = 90%)
    exit_pct: f64,
}

impl FiftyTwoWeekHighStrategy {
    pub fn new(period: usize, entry_pct: f64, exit_pct: f64) -> Self {
        assert!(period > 0, "Period must be at least 1");
        assert!(
            entry_pct > 0.0 && entry_pct <= 1.0,
            "Entry percentage must be between 0 and 1"
        );
        assert!(
            exit_pct > 0.0 && exit_pct <= 1.0,
            "Exit percentage must be between 0 and 1"
        );
        assert!(
            exit_pct < entry_pct,
            "Exit percentage must be less than entry percentage"
        );

        Self {
            period,
            entry_pct,
            exit_pct,
        }
    }

    /// Standard 52-week high (252 trading days)
    pub fn annual() -> Self {
        Self::new(252, 0.95, 0.90)
    }

    /// 6-month high (126 trading days)
    pub fn semi_annual() -> Self {
        Self::new(126, 0.95, 0.90)
    }

    /// Get the period.
    pub fn period(&self) -> usize {
        self.period
    }

    /// Get the entry percentage.
    pub fn entry_pct(&self) -> f64 {
        self.entry_pct
    }

    /// Get the exit percentage.
    pub fn exit_pct(&self) -> f64 {
        self.exit_pct
    }
}

impl Strategy for FiftyTwoWeekHighStrategy {
    fn id(&self) -> &str {
        "52wk_high"
    }

    fn warmup_period(&self) -> usize {
        self.period
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let rolling_max = rolling_max_close(bars, self.period);
        let period_high = match rolling_max[current_idx] {
            Some(h) => h,
            None => return Signal::Hold,
        };

        let current_close = bars[current_idx].close;
        let proximity = current_close / period_high;

        match current_position {
            Position::Flat => {
                // Entry: close >= entry_pct * period_high
                if proximity >= self.entry_pct {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: close < exit_pct * period_high
                if proximity < self.exit_pct {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {}
}

// =============================================================================
// FiftyTwoWeekHigh Variants
// =============================================================================

/// 52-Week High with Momentum Filter strategy.
///
/// Only enters near 52-week highs when price is accelerating (positive ROC).
/// This filters out choppy consolidation near highs.
///
/// Entry: close >= entry_pct * period_high AND ROC > momentum_threshold
/// Exit: close < exit_pct * period_high
#[derive(Debug, Clone)]
pub struct FiftyTwoWeekHighMomentumStrategy {
    period: usize,
    entry_pct: f64,
    exit_pct: f64,
    momentum_period: usize,
    momentum_threshold: f64,
}

impl FiftyTwoWeekHighMomentumStrategy {
    pub fn new(
        period: usize,
        entry_pct: f64,
        exit_pct: f64,
        momentum_period: usize,
        momentum_threshold: f64,
    ) -> Self {
        assert!(period > 0, "Period must be at least 1");
        assert!(
            entry_pct > 0.0 && entry_pct <= 1.0,
            "Entry percentage must be between 0 and 1"
        );
        assert!(
            exit_pct > 0.0 && exit_pct <= 1.0,
            "Exit percentage must be between 0 and 1"
        );
        assert!(
            exit_pct < entry_pct,
            "Exit percentage must be less than entry percentage"
        );
        assert!(momentum_period > 0, "Momentum period must be at least 1");

        Self {
            period,
            entry_pct,
            exit_pct,
            momentum_period,
            momentum_threshold,
        }
    }
}

impl Strategy for FiftyTwoWeekHighMomentumStrategy {
    fn id(&self) -> &str {
        "52wk_high_momentum"
    }

    fn warmup_period(&self) -> usize {
        self.period.max(self.momentum_period)
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let rolling_max = rolling_max_close(bars, self.period);
        let roc_values = roc(bars, self.momentum_period);

        let period_high = match rolling_max[current_idx] {
            Some(h) => h,
            None => return Signal::Hold,
        };

        let current_roc = match roc_values[current_idx] {
            Some(r) => r,
            None => return Signal::Hold,
        };

        let current_close = bars[current_idx].close;
        let proximity = current_close / period_high;

        match current_position {
            Position::Flat => {
                // Entry: near high AND positive momentum
                if proximity >= self.entry_pct && current_roc.roc >= self.momentum_threshold {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: falls below exit threshold (momentum not checked on exit)
                if proximity < self.exit_pct {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {}
}

/// 52-Week High with Trailing Stop strategy.
///
/// Uses a trailing stop from the entry price instead of a fixed exit threshold.
/// This locks in gains on strong moves.
///
/// Entry: close >= entry_pct * period_high
/// Exit: close falls trailing_stop_pct below the highest close since entry
#[derive(Debug, Clone)]
pub struct FiftyTwoWeekHighTrailingStrategy {
    period: usize,
    entry_pct: f64,
    trailing_stop_pct: f64,
    /// Highest close since entry (for trailing stop)
    high_since_entry: Option<f64>,
}

impl FiftyTwoWeekHighTrailingStrategy {
    pub fn new(period: usize, entry_pct: f64, trailing_stop_pct: f64) -> Self {
        assert!(period > 0, "Period must be at least 1");
        assert!(
            entry_pct > 0.0 && entry_pct <= 1.0,
            "Entry percentage must be between 0 and 1"
        );
        assert!(
            trailing_stop_pct > 0.0 && trailing_stop_pct < 1.0,
            "Trailing stop percentage must be between 0 and 1"
        );

        Self {
            period,
            entry_pct,
            trailing_stop_pct,
            high_since_entry: None,
        }
    }
}

impl Strategy for FiftyTwoWeekHighTrailingStrategy {
    fn id(&self) -> &str {
        "52wk_high_trailing"
    }

    fn warmup_period(&self) -> usize {
        self.period
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let rolling_max = rolling_max_close(bars, self.period);

        let period_high = match rolling_max[current_idx] {
            Some(h) => h,
            None => return Signal::Hold,
        };

        let current_close = bars[current_idx].close;
        let proximity = current_close / period_high;

        match current_position {
            Position::Flat => {
                // Entry: close >= entry_pct * period_high
                if proximity >= self.entry_pct {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Track high since entry for trailing stop calculation
                // Since strategy is stateless per signal call, we calculate trailing high from bars
                // Look for the entry point by finding last time we crossed entry threshold from below
                let mut entry_idx = current_idx;
                for i in (0..current_idx).rev() {
                    if let Some(prev_high) = rolling_max[i] {
                        let prev_proximity = bars[i].close / prev_high;
                        if prev_proximity < self.entry_pct {
                            entry_idx = i + 1;
                            break;
                        }
                    }
                }

                // Find highest close since entry
                let high_since_entry = bars[entry_idx..=current_idx]
                    .iter()
                    .map(|b| b.close)
                    .fold(f64::NEG_INFINITY, f64::max);

                // Exit if current close is trailing_stop_pct below high since entry
                let stop_level = high_since_entry * (1.0 - self.trailing_stop_pct);
                if current_close < stop_level {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {
        self.high_since_entry = None;
    }
}

/// Darvas Box Breakout strategy.
///
/// Entry: When close breaks above a confirmed box top
/// Exit: When close breaks below the box bottom
///
/// Based on Nicolas Darvas's "How I Made $2,000,000 in the Stock Market" (1960).
/// The strategy identifies consolidation boxes and trades breakouts.
#[derive(Debug, Clone)]
pub struct DarvasBoxStrategy {
    /// Number of bars needed to confirm box top/bottom
    confirmation_bars: usize,
    /// Currently tracked box (for state)
    current_box: Option<DarvasBox>,
}

impl DarvasBoxStrategy {
    pub fn new(confirmation_bars: usize) -> Self {
        assert!(
            confirmation_bars > 0,
            "Confirmation bars must be at least 1"
        );
        Self {
            confirmation_bars,
            current_box: None,
        }
    }

    /// Standard Darvas with 3-bar confirmation
    pub fn standard() -> Self {
        Self::new(3)
    }

    /// Get the confirmation bars.
    pub fn confirmation_bars(&self) -> usize {
        self.confirmation_bars
    }
}

impl Strategy for DarvasBoxStrategy {
    fn id(&self) -> &str {
        "darvas_box"
    }

    fn warmup_period(&self) -> usize {
        // Need enough bars for box formation (roughly 2x confirmation bars)
        self.confirmation_bars * 2 + 2
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let boxes = darvas_boxes(bars, self.confirmation_bars);
        let current_close = bars[current_idx].close;

        // Get current and previous box states
        let current_box = boxes[current_idx];
        let prev_box = if current_idx > 0 {
            boxes[current_idx - 1]
        } else {
            None
        };

        match current_position {
            Position::Flat => {
                // Entry: close breaks above a confirmed box top
                if let Some(ref bx) = current_box {
                    if bx.is_complete() && current_close > bx.top {
                        return Signal::EnterLong;
                    }
                }
                // Also check if we broke above previous box
                if let Some(ref bx) = prev_box {
                    if bx.is_complete() && current_close > bx.top {
                        return Signal::EnterLong;
                    }
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: close breaks below box bottom
                if let Some(ref bx) = current_box {
                    if current_close < bx.bottom {
                        return Signal::ExitLong;
                    }
                }
                if let Some(ref bx) = prev_box {
                    if current_close < bx.bottom {
                        return Signal::ExitLong;
                    }
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {
        self.current_box = None;
    }
}

/// Larry Williams Volatility Breakout strategy.
///
/// Entry: When close breaks above open + k * prior_range
/// Exit: Trailing stop at entry_price - stop_mult * ATR
///
/// This is a classic volatility breakout system that trades
/// range expansions based on the prior day's trading range.
#[derive(Debug, Clone)]
pub struct LarryWilliamsStrategy {
    /// Multiplier for range breakout (e.g., 0.5)
    range_mult: f64,
    /// ATR multiplier for trailing stop
    atr_stop_mult: f64,
    /// ATR period for stop calculation
    atr_period: usize,
    /// Entry price (for trailing stop calculation)
    entry_price: Option<f64>,
    /// ATR at entry (for trailing stop)
    entry_atr: Option<f64>,
}

impl LarryWilliamsStrategy {
    pub fn new(range_mult: f64, atr_stop_mult: f64, atr_period: usize) -> Self {
        assert!(range_mult > 0.0, "Range multiplier must be positive");
        assert!(atr_stop_mult > 0.0, "ATR stop multiplier must be positive");
        assert!(atr_period > 0, "ATR period must be at least 1");

        Self {
            range_mult,
            atr_stop_mult,
            atr_period,
            entry_price: None,
            entry_atr: None,
        }
    }

    /// Standard configuration: range_mult=0.5, atr_stop=2.0, atr_period=14
    pub fn standard() -> Self {
        Self::new(0.5, 2.0, 14)
    }

    /// Get the range multiplier.
    pub fn range_mult(&self) -> f64 {
        self.range_mult
    }

    /// Get the ATR stop multiplier.
    pub fn atr_stop_mult(&self) -> f64 {
        self.atr_stop_mult
    }

    /// Get the ATR period.
    pub fn atr_period(&self) -> usize {
        self.atr_period
    }
}

impl Strategy for LarryWilliamsStrategy {
    fn id(&self) -> &str {
        "larry_williams"
    }

    fn warmup_period(&self) -> usize {
        // Need at least 2 bars for prior range + ATR period
        self.atr_period.max(2)
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let current_bar = &bars[current_idx];
        let breakout_levels = range_breakout_levels(bars, self.range_mult);
        let (upper_breakout, _lower_breakout) = breakout_levels[current_idx];

        let atr_values = atr(bars, self.atr_period);
        let current_atr = atr_values[current_idx];

        match current_position {
            Position::Flat => {
                // Entry: close > upper_breakout (open + k * prior_range)
                if current_bar.close > upper_breakout {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: trailing stop using ATR
                // For a stateless check, we use a simple condition:
                // If close drops significantly below recent high, exit
                // This is a simplified version - full implementation would track entry price
                if let Some(current_atr_val) = current_atr {
                    // Simple trailing stop: if we're down more than atr_stop_mult * ATR
                    // from the recent high, exit
                    if current_idx > 0 {
                        let recent_high = bars[..=current_idx]
                            .iter()
                            .rev()
                            .take(5) // Look at last 5 bars
                            .map(|b| b.high)
                            .fold(f64::NEG_INFINITY, f64::max);

                        let stop_level = recent_high - self.atr_stop_mult * current_atr_val;
                        if current_bar.close < stop_level {
                            return Signal::ExitLong;
                        }
                    }
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {
        self.entry_price = None;
        self.entry_atr = None;
    }
}

/// Heikin-Ashi Regime strategy.
///
/// Entry: First bullish HA candle after bearish sequence
/// Exit: First bearish HA candle after entry
///
/// Heikin-Ashi candles smooth price action to make trend
/// identification easier. This strategy trades regime changes.
#[derive(Debug, Clone)]
pub struct HeikinAshiRegimeStrategy {
    /// Number of confirmation bars needed
    confirmation_bars: usize,
}

impl HeikinAshiRegimeStrategy {
    pub fn new(confirmation_bars: usize) -> Self {
        assert!(
            confirmation_bars > 0,
            "Confirmation bars must be at least 1"
        );
        Self { confirmation_bars }
    }

    /// Standard configuration with 1-bar confirmation
    pub fn standard() -> Self {
        Self::new(1)
    }

    /// Get the confirmation bars.
    pub fn confirmation_bars(&self) -> usize {
        self.confirmation_bars
    }

    /// Count consecutive bearish HA bars before current index.
    fn count_prior_bearish(&self, ha_bars: &[HABar], current_idx: usize) -> usize {
        let mut count = 0;
        for i in (0..current_idx).rev() {
            if ha_bars[i].is_bearish() {
                count += 1;
            } else {
                break;
            }
        }
        count
    }
}

impl Strategy for HeikinAshiRegimeStrategy {
    fn id(&self) -> &str {
        "heikin_ashi"
    }

    fn warmup_period(&self) -> usize {
        // Need enough prior bars to count `confirmation_bars` consecutive candles.
        // (HA itself is defined from the very first bar.)
        self.confirmation_bars
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let ha_bars = heikin_ashi(bars);
        let current_ha = &ha_bars[current_idx];

        match current_position {
            Position::Flat => {
                // Entry: First bullish HA after bearish sequence
                if current_ha.is_bullish() {
                    let prior_bearish_count = self.count_prior_bearish(&ha_bars, current_idx);
                    if prior_bearish_count >= self.confirmation_bars {
                        return Signal::EnterLong;
                    }
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: First bearish HA after entry
                if current_ha.is_bearish() {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {}
}

// =============================================================================
// Phase 4: Complex Stateful + Ensemble Strategies
// =============================================================================

/// Parabolic SAR strategy.
///
/// Entry: SAR flips from above to below price (uptrend begins)
/// Exit: SAR flips from below to above price (downtrend begins)
///
/// Based on J. Welles Wilder's Parabolic Stop and Reverse system.
/// The SAR trails price, accelerating as the trend develops.
/// AF (Acceleration Factor) increases with each new extreme price.
///
/// Common configurations:
/// - AF 0.02/0.02/0.20: Standard (Wilder's original)
/// - AF 0.01/0.01/0.10: Slower, fewer whipsaws
/// - AF 0.03/0.03/0.30: Faster, more responsive
#[derive(Debug, Clone)]
pub struct ParabolicSARStrategy {
    /// Starting acceleration factor
    af_start: f64,
    /// Acceleration factor step increment
    af_step: f64,
    /// Maximum acceleration factor
    af_max: f64,
}

impl ParabolicSARStrategy {
    pub fn new(af_start: f64, af_step: f64, af_max: f64) -> Self {
        assert!(af_start > 0.0, "AF start must be positive");
        assert!(af_step > 0.0, "AF step must be positive");
        assert!(af_max >= af_start, "AF max must be >= AF start");

        Self {
            af_start,
            af_step,
            af_max,
        }
    }

    /// Standard Wilder configuration: 0.02/0.02/0.20
    pub fn standard() -> Self {
        Self::new(0.02, 0.02, 0.20)
    }

    /// Slow configuration for fewer whipsaws: 0.01/0.01/0.10
    pub fn slow() -> Self {
        Self::new(0.01, 0.01, 0.10)
    }

    /// Fast configuration for quicker response: 0.03/0.03/0.30
    pub fn fast() -> Self {
        Self::new(0.03, 0.03, 0.30)
    }

    /// Get the starting AF.
    pub fn af_start(&self) -> f64 {
        self.af_start
    }

    /// Get the AF step.
    pub fn af_step(&self) -> f64 {
        self.af_step
    }

    /// Get the maximum AF.
    pub fn af_max(&self) -> f64 {
        self.af_max
    }
}

impl Strategy for ParabolicSARStrategy {
    fn id(&self) -> &str {
        "parabolic_sar"
    }

    fn warmup_period(&self) -> usize {
        5 // SAR needs a few bars to establish initial trend direction
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let sar_values = parabolic_sar(bars, self.af_start, self.af_step, self.af_max);

        // Get current and previous SAR values
        let current_sar = match sar_values[current_idx] {
            Some(ref s) => s,
            None => return Signal::Hold,
        };

        // Need previous bar for flip detection
        if current_idx == 0 {
            return Signal::Hold;
        }

        let prev_sar = sar_values[current_idx - 1].as_ref();

        match current_position {
            Position::Flat => {
                // Entry: SAR flips to uptrend (was downtrend, now uptrend).
                //
                // If the series begins in an uptrend, there may be no bullish flip.
                // In that case, enter on the first bar after warmup when SAR is already bullish.
                let warmup_boundary_entry =
                    current_idx == self.warmup_period() && current_sar.is_uptrend;

                if current_sar.just_flipped_bullish(prev_sar) || warmup_boundary_entry {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: SAR flips to downtrend (was uptrend, now downtrend)
                if current_sar.just_flipped_bearish(prev_sar) {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {}
}

// =============================================================================
// ParabolicSAR Variants
// =============================================================================

/// Parabolic SAR with MA Trend Filter strategy.
///
/// Only enters on SAR flip when price is above a long-term moving average,
/// filtering out ranging-market whipsaws.
///
/// Entry: SAR flips bullish AND close > MA(trend_ma_period)
/// Exit: SAR flips bearish
#[derive(Debug, Clone)]
pub struct ParabolicSarFilteredStrategy {
    af_start: f64,
    af_step: f64,
    af_max: f64,
    trend_ma_period: usize,
}

impl ParabolicSarFilteredStrategy {
    pub fn new(af_start: f64, af_step: f64, af_max: f64, trend_ma_period: usize) -> Self {
        assert!(af_start > 0.0, "AF start must be positive");
        assert!(af_step > 0.0, "AF step must be positive");
        assert!(af_max >= af_start, "AF max must be >= AF start");
        assert!(trend_ma_period > 0, "Trend MA period must be at least 1");

        Self {
            af_start,
            af_step,
            af_max,
            trend_ma_period,
        }
    }
}

impl Strategy for ParabolicSarFilteredStrategy {
    fn id(&self) -> &str {
        "parabolic_sar_filtered"
    }

    fn warmup_period(&self) -> usize {
        5.max(self.trend_ma_period)
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let sar_values = parabolic_sar(bars, self.af_start, self.af_step, self.af_max);
        let ma_values = sma_close(bars, self.trend_ma_period);

        let current_sar = match sar_values[current_idx] {
            Some(ref s) => s,
            None => return Signal::Hold,
        };

        let trend_ma = match ma_values[current_idx] {
            Some(m) => m,
            None => return Signal::Hold,
        };

        if current_idx == 0 {
            return Signal::Hold;
        }

        let prev_sar = sar_values[current_idx - 1].as_ref();

        match current_position {
            Position::Flat => {
                // Entry: SAR flips bullish AND price above MA
                let current_close = bars[current_idx].close;
                if current_sar.just_flipped_bullish(prev_sar) && current_close > trend_ma {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: SAR flips bearish (no MA filter on exits)
                if current_sar.just_flipped_bearish(prev_sar) {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {}
}

/// Parabolic SAR with Entry Delay strategy.
///
/// Waits N bars after SAR flip before entering, confirming the flip isn't a false signal.
///
/// Entry: SAR flipped bullish N bars ago and still bullish
/// Exit: SAR flips bearish
#[derive(Debug, Clone)]
pub struct ParabolicSarDelayedStrategy {
    af_start: f64,
    af_step: f64,
    af_max: f64,
    delay_bars: usize,
}

impl ParabolicSarDelayedStrategy {
    pub fn new(af_start: f64, af_step: f64, af_max: f64, delay_bars: usize) -> Self {
        assert!(af_start > 0.0, "AF start must be positive");
        assert!(af_step > 0.0, "AF step must be positive");
        assert!(af_max >= af_start, "AF max must be >= AF start");
        assert!(delay_bars > 0, "Delay bars must be at least 1");

        Self {
            af_start,
            af_step,
            af_max,
            delay_bars,
        }
    }
}

impl Strategy for ParabolicSarDelayedStrategy {
    fn id(&self) -> &str {
        "parabolic_sar_delayed"
    }

    fn warmup_period(&self) -> usize {
        5 + self.delay_bars
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let sar_values = parabolic_sar(bars, self.af_start, self.af_step, self.af_max);

        let current_sar = match sar_values[current_idx] {
            Some(ref s) => s,
            None => return Signal::Hold,
        };

        if current_idx == 0 {
            return Signal::Hold;
        }

        let prev_sar = sar_values[current_idx - 1].as_ref();

        match current_position {
            Position::Flat => {
                // Check if SAR flipped bullish exactly delay_bars ago
                if current_idx >= self.delay_bars {
                    let flip_idx = current_idx - self.delay_bars;
                    if flip_idx > 0 {
                        let flip_sar = sar_values[flip_idx].as_ref();
                        let pre_flip_sar = sar_values[flip_idx - 1].as_ref();

                        if let Some(fs) = flip_sar {
                            // Check if flip occurred at flip_idx
                            if fs.just_flipped_bullish(pre_flip_sar) {
                                // Verify still in uptrend
                                if current_sar.is_uptrend {
                                    return Signal::EnterLong;
                                }
                            }
                        }
                    }
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: SAR flips bearish (no delay on exits)
                if current_sar.just_flipped_bearish(prev_sar) {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {}
}

/// Opening Range Breakout strategy.
///
/// Entry: Close breaks above the opening range high (after range complete)
/// Exit: Close breaks below the opening range low
///
/// The "opening range" is defined as the high/low of the first N bars
/// of a trading period (week, month, or rolling).
///
/// Common configurations:
/// - 5 bars, Weekly: First week's range, trade breakouts for rest of month
/// - 3 bars, Rolling: Simple rolling range breakout
/// - 10 bars, Monthly: First 2 weeks define range for month
#[derive(Debug, Clone)]
pub struct OpeningRangeBreakoutStrategy {
    /// Number of bars to define the opening range
    range_bars: usize,
    /// Period type for range detection
    period: OpeningPeriod,
}

impl OpeningRangeBreakoutStrategy {
    pub fn new(range_bars: usize, period: OpeningPeriod) -> Self {
        assert!(range_bars > 0, "Range bars must be at least 1");

        Self { range_bars, period }
    }

    /// Standard weekly range with 5 bars
    pub fn weekly_5() -> Self {
        Self::new(5, OpeningPeriod::Weekly)
    }

    /// Standard monthly range with 10 bars
    pub fn monthly_10() -> Self {
        Self::new(10, OpeningPeriod::Monthly)
    }

    /// Rolling range with 3 bars
    pub fn rolling_3() -> Self {
        Self::new(3, OpeningPeriod::Rolling)
    }

    /// Get the range bars.
    pub fn range_bars(&self) -> usize {
        self.range_bars
    }

    /// Get the period.
    pub fn period(&self) -> &OpeningPeriod {
        &self.period
    }
}

impl Strategy for OpeningRangeBreakoutStrategy {
    fn id(&self) -> &str {
        "opening_range_breakout"
    }

    fn warmup_period(&self) -> usize {
        self.range_bars
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let or_values = opening_range(bars, self.range_bars, self.period);

        let current_or = match or_values[current_idx] {
            Some(ref r) => r,
            None => return Signal::Hold,
        };

        // Only trade after range is complete
        if !current_or.is_range_complete {
            return Signal::Hold;
        }

        let current_close = bars[current_idx].close;

        match current_position {
            Position::Flat => {
                // Entry: close breaks above range high
                if current_or.is_breakout_high(current_close) {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: close breaks below range low
                if current_or.is_breakout_low(current_close) {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {}
}

/// Voting method for ensemble strategies.
#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum VotingMethod {
    /// Simple majority vote (>50% must agree)
    Majority,
    /// Weighted by horizon (longer horizons get more weight)
    WeightedByHorizon,
    /// All strategies must agree for entry, any triggers exit
    UnanimousEntry,
}

impl VotingMethod {
    /// Vote on signals using the specified method.
    ///
    /// Returns the aggregated signal based on voting rules.
    pub fn vote(&self, signals: &[Signal], horizons: &[usize]) -> Signal {
        if signals.is_empty() {
            return Signal::Hold;
        }

        match self {
            VotingMethod::Majority => Self::majority_vote(signals),
            VotingMethod::WeightedByHorizon => Self::weighted_vote(signals, horizons),
            VotingMethod::UnanimousEntry => Self::unanimous_entry_vote(signals),
        }
    }

    fn majority_vote(signals: &[Signal]) -> Signal {
        let n = signals.len();
        let majority = n / 2 + 1;

        let entry_count = signals.iter().filter(|s| s.is_entry()).count();
        let exit_count = signals.iter().filter(|s| s.is_exit()).count();

        if entry_count >= majority {
            // Return most common entry type
            let long_entries = signals
                .iter()
                .filter(|s| matches!(s, Signal::EnterLong))
                .count();
            if long_entries >= majority {
                return Signal::EnterLong;
            }
        }

        if exit_count >= majority {
            let long_exits = signals
                .iter()
                .filter(|s| matches!(s, Signal::ExitLong))
                .count();
            if long_exits >= majority {
                return Signal::ExitLong;
            }
        }

        Signal::Hold
    }

    fn weighted_vote(signals: &[Signal], horizons: &[usize]) -> Signal {
        if signals.len() != horizons.len() {
            return Signal::Hold;
        }

        let total_weight: usize = horizons.iter().sum();
        if total_weight == 0 {
            return Signal::Hold;
        }

        let mut entry_weight = 0usize;
        let mut exit_weight = 0usize;

        for (signal, &horizon) in signals.iter().zip(horizons.iter()) {
            match signal {
                Signal::EnterLong | Signal::EnterShort => entry_weight += horizon,
                Signal::ExitLong | Signal::ExitShort => exit_weight += horizon,
                _ => {}
            }
        }

        let threshold = total_weight / 2;

        if entry_weight > threshold {
            // Determine if long or short based on signals
            let long_weight: usize = signals
                .iter()
                .zip(horizons.iter())
                .filter(|(s, _)| matches!(s, Signal::EnterLong))
                .map(|(_, h)| h)
                .sum();
            if long_weight > threshold {
                return Signal::EnterLong;
            }
        }

        if exit_weight > threshold {
            let long_exit_weight: usize = signals
                .iter()
                .zip(horizons.iter())
                .filter(|(s, _)| matches!(s, Signal::ExitLong))
                .map(|(_, h)| h)
                .sum();
            if long_exit_weight > threshold {
                return Signal::ExitLong;
            }
        }

        Signal::Hold
    }

    fn unanimous_entry_vote(signals: &[Signal]) -> Signal {
        // For entry: ALL must agree
        // For exit: ANY triggers exit
        let all_entry_long = signals.iter().all(|s| matches!(s, Signal::EnterLong));
        let all_entry_short = signals.iter().all(|s| matches!(s, Signal::EnterShort));
        let any_exit_long = signals.iter().any(|s| matches!(s, Signal::ExitLong));
        let any_exit_short = signals.iter().any(|s| matches!(s, Signal::ExitShort));

        if any_exit_long {
            return Signal::ExitLong;
        }
        if any_exit_short {
            return Signal::ExitShort;
        }
        if all_entry_long {
            return Signal::EnterLong;
        }
        if all_entry_short {
            return Signal::EnterShort;
        }

        Signal::Hold
    }
}

/// Multi-Horizon Ensemble strategy.
///
/// Combines multiple strategy instances with different parameterizations
/// (typically different lookback periods / horizons) and aggregates
/// their signals using a voting mechanism.
///
/// Common configurations:
/// - Donchian Triple: 20/55/100 day lookbacks
/// - MA Triple: 10/50/200 day crossovers
/// - TSMOM Multi: 21/63/126/252 day momentum
pub struct EnsembleStrategy {
    /// Child strategies to combine
    strategies: Vec<Box<dyn Strategy>>,
    /// Horizons (lookback periods) for weighting
    horizons: Vec<usize>,
    /// Voting method for signal aggregation
    voting: VotingMethod,
}

impl std::fmt::Debug for EnsembleStrategy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("EnsembleStrategy")
            .field(
                "strategies",
                &format!("[{} strategies]", self.strategies.len()),
            )
            .field("horizons", &self.horizons)
            .field("voting", &self.voting)
            .finish()
    }
}

impl EnsembleStrategy {
    pub fn new(
        strategies: Vec<Box<dyn Strategy>>,
        horizons: Vec<usize>,
        voting: VotingMethod,
    ) -> Self {
        assert!(
            !strategies.is_empty(),
            "Ensemble must have at least one strategy"
        );
        assert_eq!(
            strategies.len(),
            horizons.len(),
            "Strategies and horizons must have same length"
        );

        Self {
            strategies,
            horizons,
            voting,
        }
    }

    /// Create a Donchian Triple ensemble (20/55/100 day breakouts).
    pub fn donchian_triple() -> Self {
        let strategies: Vec<Box<dyn Strategy>> = vec![
            Box::new(DonchianBreakoutStrategy::new(20, 10)),
            Box::new(DonchianBreakoutStrategy::new(55, 20)),
            Box::new(DonchianBreakoutStrategy::new(100, 40)),
        ];
        let horizons = vec![20, 55, 100];
        Self::new(strategies, horizons, VotingMethod::Majority)
    }

    /// Create an MA Triple ensemble (10/50/200 crossovers).
    pub fn ma_triple() -> Self {
        let strategies: Vec<Box<dyn Strategy>> = vec![
            Box::new(MACrossoverStrategy::new(5, 10, MAType::EMA)),
            Box::new(MACrossoverStrategy::new(20, 50, MAType::SMA)),
            Box::new(MACrossoverStrategy::new(50, 200, MAType::SMA)),
        ];
        let horizons = vec![10, 50, 200];
        Self::new(strategies, horizons, VotingMethod::WeightedByHorizon)
    }

    /// Create a TSMOM Multi ensemble (21/63/126/252 day momentum).
    pub fn tsmom_multi() -> Self {
        let strategies: Vec<Box<dyn Strategy>> = vec![
            Box::new(TsmomStrategy::new(21)),
            Box::new(TsmomStrategy::new(63)),
            Box::new(TsmomStrategy::new(126)),
            Box::new(TsmomStrategy::new(252)),
        ];
        let horizons = vec![21, 63, 126, 252];
        Self::new(strategies, horizons, VotingMethod::Majority)
    }

    /// Create an ensemble from a base strategy type and horizons.
    ///
    /// Each horizon creates a separate instance of the base strategy:
    /// - For Donchian: horizon becomes entry_lookback, exit is horizon/2
    /// - For MACrossover: horizon becomes slow period, fast is horizon/4
    /// - For TSMOM: horizon is the lookback period directly
    pub fn from_base_strategy(
        base_strategy: crate::sweep::StrategyTypeId,
        horizons: Vec<usize>,
        voting: VotingMethod,
    ) -> Self {
        let strategies: Vec<Box<dyn Strategy>> = horizons
            .iter()
            .map(|&h| -> Box<dyn Strategy> {
                match base_strategy {
                    crate::sweep::StrategyTypeId::Donchian => {
                        Box::new(DonchianBreakoutStrategy::new(h, h / 2))
                    }
                    crate::sweep::StrategyTypeId::TurtleS1 => {
                        Box::new(DonchianBreakoutStrategy::turtle_system_1())
                    }
                    crate::sweep::StrategyTypeId::TurtleS2 => {
                        Box::new(DonchianBreakoutStrategy::turtle_system_2())
                    }
                    crate::sweep::StrategyTypeId::MACrossover => {
                        Box::new(MACrossoverStrategy::new(h / 4, h, MAType::SMA))
                    }
                    crate::sweep::StrategyTypeId::Tsmom => Box::new(TsmomStrategy::new(h)),
                    // For other strategy types, default to Donchian with horizon
                    _ => Box::new(DonchianBreakoutStrategy::new(h, h / 2)),
                }
            })
            .collect();

        Self::new(strategies, horizons, voting)
    }

    /// Get the voting method.
    pub fn voting(&self) -> VotingMethod {
        self.voting
    }

    /// Get the horizons.
    pub fn horizons(&self) -> &[usize] {
        &self.horizons
    }

    /// Get the number of child strategies.
    pub fn num_strategies(&self) -> usize {
        self.strategies.len()
    }
}

impl Strategy for EnsembleStrategy {
    fn id(&self) -> &str {
        "ensemble"
    }

    fn warmup_period(&self) -> usize {
        // Warmup is the max of all child strategy warmups
        self.strategies
            .iter()
            .map(|s| s.warmup_period())
            .max()
            .unwrap_or(0)
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        // Collect signals from all child strategies
        let signals: Vec<Signal> = self
            .strategies
            .iter()
            .map(|s| s.signal(bars, current_position))
            .collect();

        // Aggregate using voting method
        self.voting.vote(&signals, &self.horizons)
    }

    fn reset(&mut self) {
        for strategy in &mut self.strategies {
            strategy.reset();
        }
    }
}

// =============================================================================
// Phase 5: Oscillator Strategies
// =============================================================================

/// RSI (Relative Strength Index) Strategy.
///
/// Entry: RSI crosses above oversold threshold from below (bullish crossover)
/// Exit: RSI crosses below overbought threshold from above (bearish crossover)
///
/// The RSI measures the speed and magnitude of price changes.
/// Values range from 0 to 100, with readings below 30 typically
/// considered oversold and above 70 considered overbought.
///
/// Common configurations:
/// - Period 14, Oversold 30, Overbought 70: Standard (Wilder's original)
/// - Period 7, Oversold 20, Overbought 80: More extreme levels
/// - Period 21, Oversold 30, Overbought 70: Smoother signals
#[derive(Debug, Clone)]
pub struct RSIStrategy {
    /// Period for RSI calculation
    period: usize,
    /// Oversold threshold (entry when crossing above)
    oversold: f64,
    /// Overbought threshold (exit when crossing below)
    overbought: f64,
}

impl RSIStrategy {
    pub fn new(period: usize, oversold: f64, overbought: f64) -> Self {
        assert!(period > 0, "Period must be at least 1");
        assert!(
            oversold > 0.0 && oversold < 100.0,
            "Oversold must be between 0 and 100"
        );
        assert!(
            overbought > 0.0 && overbought < 100.0,
            "Overbought must be between 0 and 100"
        );
        assert!(
            oversold < overbought,
            "Oversold must be less than overbought"
        );

        Self {
            period,
            oversold,
            overbought,
        }
    }

    /// Standard configuration: period 14, oversold 30, overbought 70
    pub fn standard() -> Self {
        Self::new(14, 30.0, 70.0)
    }

    /// Extreme configuration: period 7, oversold 20, overbought 80
    pub fn extreme() -> Self {
        Self::new(7, 20.0, 80.0)
    }

    /// Smooth configuration: period 21, oversold 30, overbought 70
    pub fn smooth() -> Self {
        Self::new(21, 30.0, 70.0)
    }

    /// Get the period.
    pub fn period(&self) -> usize {
        self.period
    }

    /// Get the oversold threshold.
    pub fn oversold(&self) -> f64 {
        self.oversold
    }

    /// Get the overbought threshold.
    pub fn overbought(&self) -> f64 {
        self.overbought
    }
}

impl Strategy for RSIStrategy {
    fn id(&self) -> &str {
        "rsi"
    }

    fn warmup_period(&self) -> usize {
        // RSI needs period + 1 bars for Wilder smoothing
        self.period + 1
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let rsi_values = rsi(bars, self.period);

        // Get current and previous RSI values
        let current_rsi = match rsi_values[current_idx] {
            Some(ref r) => r.rsi,
            None => return Signal::Hold,
        };

        // Need previous bar for crossover detection
        if current_idx == 0 {
            return Signal::Hold;
        }

        let prev_rsi = match rsi_values[current_idx - 1] {
            Some(ref r) => r.rsi,
            None => return Signal::Hold,
        };

        match current_position {
            Position::Flat => {
                // Entry: RSI crosses above oversold threshold
                if current_rsi > self.oversold && prev_rsi <= self.oversold {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: RSI crosses below overbought threshold
                if current_rsi < self.overbought && prev_rsi >= self.overbought {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {}
}

/// MACD (Moving Average Convergence Divergence) Strategy.
///
/// Entry modes:
/// - CrossSignal: MACD line crosses above signal line
/// - CrossZero: MACD line crosses above zero line
/// - Histogram: Histogram turns positive (MACD > Signal)
///
/// Exit: Opposite of entry condition
///
/// Common configurations:
/// - 12/26/9: Standard (most common)
/// - 8/17/9: Short-term
/// - 5/35/5: Longer-term smoothing
#[derive(Debug, Clone)]
pub struct MACDStrategy {
    /// Fast EMA period
    fast_period: usize,
    /// Slow EMA period
    slow_period: usize,
    /// Signal line EMA period
    signal_period: usize,
    /// Entry mode
    entry_mode: MACDEntryMode,
}

impl MACDStrategy {
    pub fn new(
        fast_period: usize,
        slow_period: usize,
        signal_period: usize,
        entry_mode: MACDEntryMode,
    ) -> Self {
        assert!(fast_period > 0, "Fast period must be at least 1");
        assert!(slow_period > 0, "Slow period must be at least 1");
        assert!(
            fast_period < slow_period,
            "Fast period must be less than slow period"
        );
        assert!(signal_period > 0, "Signal period must be at least 1");

        Self {
            fast_period,
            slow_period,
            signal_period,
            entry_mode,
        }
    }

    /// Standard configuration: 12/26/9 with CrossSignal mode
    pub fn standard() -> Self {
        Self::new(12, 26, 9, MACDEntryMode::CrossSignal)
    }

    /// Short-term configuration: 8/17/9
    pub fn short_term() -> Self {
        Self::new(8, 17, 9, MACDEntryMode::CrossSignal)
    }

    /// Zero-cross configuration: 12/26/9 with CrossZero mode
    pub fn zero_cross() -> Self {
        Self::new(12, 26, 9, MACDEntryMode::CrossZero)
    }

    /// Histogram configuration: 12/26/9 with Histogram mode
    pub fn histogram() -> Self {
        Self::new(12, 26, 9, MACDEntryMode::Histogram)
    }

    /// Get the fast period.
    pub fn fast_period(&self) -> usize {
        self.fast_period
    }

    /// Get the slow period.
    pub fn slow_period(&self) -> usize {
        self.slow_period
    }

    /// Get the signal period.
    pub fn signal_period(&self) -> usize {
        self.signal_period
    }

    /// Get the entry mode.
    pub fn entry_mode(&self) -> MACDEntryMode {
        self.entry_mode
    }
}

impl Strategy for MACDStrategy {
    fn id(&self) -> &str {
        "macd"
    }

    fn warmup_period(&self) -> usize {
        // MACD needs slow_period + signal_period for full calculation
        self.slow_period + self.signal_period
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let macd_values = macd(bars, self.fast_period, self.slow_period, self.signal_period);

        // Get current and previous MACD values
        let current_macd = match macd_values[current_idx] {
            Some(ref m) => m,
            None => return Signal::Hold,
        };

        // Need previous bar for crossover detection
        if current_idx == 0 {
            return Signal::Hold;
        }

        let prev_macd = match macd_values[current_idx - 1] {
            Some(ref m) => m,
            None => return Signal::Hold,
        };

        match self.entry_mode {
            MACDEntryMode::CrossSignal => {
                let macd_above_signal = current_macd.macd_line > current_macd.signal_line;
                let prev_macd_above_signal = prev_macd.macd_line > prev_macd.signal_line;

                match current_position {
                    Position::Flat => {
                        // Entry: MACD crosses above signal line
                        if macd_above_signal && !prev_macd_above_signal {
                            return Signal::EnterLong;
                        }
                        Signal::Hold
                    }
                    Position::Long => {
                        // Exit: MACD crosses below signal line
                        if !macd_above_signal && prev_macd_above_signal {
                            return Signal::ExitLong;
                        }
                        Signal::Hold
                    }
                    Position::Short => Signal::Hold,
                }
            }
            MACDEntryMode::CrossZero => {
                let macd_above_zero = current_macd.macd_line > 0.0;
                let prev_macd_above_zero = prev_macd.macd_line > 0.0;

                match current_position {
                    Position::Flat => {
                        // Entry: MACD crosses above zero
                        if macd_above_zero && !prev_macd_above_zero {
                            return Signal::EnterLong;
                        }
                        Signal::Hold
                    }
                    Position::Long => {
                        // Exit: MACD crosses below zero
                        if !macd_above_zero && prev_macd_above_zero {
                            return Signal::ExitLong;
                        }
                        Signal::Hold
                    }
                    Position::Short => Signal::Hold,
                }
            }
            MACDEntryMode::Histogram => {
                let histogram_positive = current_macd.histogram > 0.0;
                let prev_histogram_positive = prev_macd.histogram > 0.0;

                match current_position {
                    Position::Flat => {
                        // Entry: Histogram turns positive
                        if histogram_positive && !prev_histogram_positive {
                            return Signal::EnterLong;
                        }
                        Signal::Hold
                    }
                    Position::Long => {
                        // Exit: Histogram turns negative
                        if !histogram_positive && prev_histogram_positive {
                            return Signal::ExitLong;
                        }
                        Signal::Hold
                    }
                    Position::Short => Signal::Hold,
                }
            }
        }
    }

    fn reset(&mut self) {}
}

/// Stochastic Oscillator Strategy.
///
/// Entry: %K crosses above %D when both are below oversold threshold
/// Exit: %K crosses below %D when both are above overbought threshold
///
/// The stochastic oscillator compares closing price to the price range
/// over a given period. Values range from 0 to 100.
///
/// Common configurations:
/// - 14/3/3, Oversold 20, Overbought 80: Standard
/// - 5/3/3, Oversold 20, Overbought 80: Fast stochastic
/// - 21/5/5, Oversold 20, Overbought 80: Slow stochastic
#[derive(Debug, Clone)]
pub struct StochasticStrategy {
    /// %K period (lookback for high/low range)
    k_period: usize,
    /// %K smoothing period
    k_smooth: usize,
    /// %D period (signal line smoothing)
    d_period: usize,
    /// Oversold threshold
    oversold: f64,
    /// Overbought threshold
    overbought: f64,
}

impl StochasticStrategy {
    pub fn new(
        k_period: usize,
        k_smooth: usize,
        d_period: usize,
        oversold: f64,
        overbought: f64,
    ) -> Self {
        assert!(k_period > 0, "K period must be at least 1");
        assert!(k_smooth > 0, "K smooth must be at least 1");
        assert!(d_period > 0, "D period must be at least 1");
        assert!(
            oversold > 0.0 && oversold < 100.0,
            "Oversold must be between 0 and 100"
        );
        assert!(
            overbought > 0.0 && overbought < 100.0,
            "Overbought must be between 0 and 100"
        );
        assert!(
            oversold < overbought,
            "Oversold must be less than overbought"
        );

        Self {
            k_period,
            k_smooth,
            d_period,
            oversold,
            overbought,
        }
    }

    /// Standard configuration: 14/3/3, 20/80
    pub fn standard() -> Self {
        Self::new(14, 3, 3, 20.0, 80.0)
    }

    /// Fast stochastic: 5/3/3, 20/80
    pub fn fast() -> Self {
        Self::new(5, 3, 3, 20.0, 80.0)
    }

    /// Slow stochastic: 21/5/5, 20/80
    pub fn slow() -> Self {
        Self::new(21, 5, 5, 20.0, 80.0)
    }

    /// Get the K period.
    pub fn k_period(&self) -> usize {
        self.k_period
    }

    /// Get the K smoothing period.
    pub fn k_smooth(&self) -> usize {
        self.k_smooth
    }

    /// Get the D period.
    pub fn d_period(&self) -> usize {
        self.d_period
    }

    /// Get the oversold threshold.
    pub fn oversold(&self) -> f64 {
        self.oversold
    }

    /// Get the overbought threshold.
    pub fn overbought(&self) -> f64 {
        self.overbought
    }
}

impl Strategy for StochasticStrategy {
    fn id(&self) -> &str {
        "stochastic"
    }

    fn warmup_period(&self) -> usize {
        // Need K period + K smooth + D period
        self.k_period + self.k_smooth + self.d_period
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let stoch_values = stochastic(bars, self.k_period, self.k_smooth, self.d_period);

        // Get current and previous stochastic values
        let current_stoch = match stoch_values[current_idx] {
            Some(ref s) => s,
            None => return Signal::Hold,
        };

        // Need previous bar for crossover detection
        if current_idx == 0 {
            return Signal::Hold;
        }

        let prev_stoch = match stoch_values[current_idx - 1] {
            Some(ref s) => s,
            None => return Signal::Hold,
        };

        let k_above_d = current_stoch.k_smooth > current_stoch.d;
        let prev_k_above_d = prev_stoch.k_smooth > prev_stoch.d;

        match current_position {
            Position::Flat => {
                // Entry: %K crosses above %D when both are in oversold territory
                let in_oversold =
                    current_stoch.k_smooth < self.oversold && current_stoch.d < self.oversold;
                if k_above_d && !prev_k_above_d && in_oversold {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: %K crosses below %D when both are in overbought territory
                let in_overbought =
                    current_stoch.k_smooth > self.overbought && current_stoch.d > self.overbought;
                if !k_above_d && prev_k_above_d && in_overbought {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {}
}

/// Williams %R Strategy.
///
/// Entry: %R crosses above oversold threshold (-80) from below
/// Exit: %R crosses below overbought threshold (-20) from above
///
/// Williams %R is an inverse of the Fast Stochastic Oscillator.
/// Values range from -100 (oversold) to 0 (overbought).
///
/// Common configurations:
/// - Period 14, Oversold -80, Overbought -20: Standard
/// - Period 10, Oversold -90, Overbought -10: More extreme
/// - Period 21, Oversold -80, Overbought -20: Smoother
#[derive(Debug, Clone)]
pub struct WilliamsRStrategy {
    /// Period for high/low range
    period: usize,
    /// Oversold threshold (typically -80)
    oversold: f64,
    /// Overbought threshold (typically -20)
    overbought: f64,
}

impl WilliamsRStrategy {
    pub fn new(period: usize, oversold: f64, overbought: f64) -> Self {
        assert!(period > 0, "Period must be at least 1");
        assert!(
            (-100.0..0.0).contains(&oversold),
            "Oversold must be between -100 and 0"
        );
        assert!(
            overbought > -100.0 && overbought <= 0.0,
            "Overbought must be between -100 and 0"
        );
        assert!(
            oversold < overbought,
            "Oversold must be less than overbought"
        );

        Self {
            period,
            oversold,
            overbought,
        }
    }

    /// Standard configuration: period 14, -80/-20
    pub fn standard() -> Self {
        Self::new(14, -80.0, -20.0)
    }

    /// Extreme configuration: period 10, -90/-10
    pub fn extreme() -> Self {
        Self::new(10, -90.0, -10.0)
    }

    /// Smooth configuration: period 21, -80/-20
    pub fn smooth() -> Self {
        Self::new(21, -80.0, -20.0)
    }

    /// Get the period.
    pub fn period(&self) -> usize {
        self.period
    }

    /// Get the oversold threshold.
    pub fn oversold(&self) -> f64 {
        self.oversold
    }

    /// Get the overbought threshold.
    pub fn overbought(&self) -> f64 {
        self.overbought
    }
}

impl Strategy for WilliamsRStrategy {
    fn id(&self) -> &str {
        "williams_r"
    }

    fn warmup_period(&self) -> usize {
        self.period
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let wr_values = williams_r(bars, self.period);

        // Get current and previous Williams %R values
        let current_wr = match wr_values[current_idx] {
            Some(ref w) => w.williams_r,
            None => return Signal::Hold,
        };

        // Need previous bar for crossover detection
        if current_idx == 0 {
            return Signal::Hold;
        }

        let prev_wr = match wr_values[current_idx - 1] {
            Some(ref w) => w.williams_r,
            None => return Signal::Hold,
        };

        match current_position {
            Position::Flat => {
                // Entry: %R crosses above oversold threshold
                if current_wr > self.oversold && prev_wr <= self.oversold {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: %R crosses below overbought threshold
                if current_wr < self.overbought && prev_wr >= self.overbought {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {}
}

/// CCI (Commodity Channel Index) Strategy.
///
/// Entry: CCI crosses above +100 (trend breakout)
/// Exit: CCI crosses below -100 (trend breakdown)
///
/// CCI measures the deviation of price from its statistical mean.
/// Readings above +100 indicate overbought (strong uptrend),
/// readings below -100 indicate oversold (strong downtrend).
///
/// Common configurations:
/// - Period 20, Entry +100, Exit -100: Standard
/// - Period 14, Entry +100, Exit -100: Faster
/// - Period 40, Entry +150, Exit -150: More conservative
#[derive(Debug, Clone)]
pub struct CCIStrategy {
    /// Period for CCI calculation
    period: usize,
    /// Entry threshold (typically +100)
    entry_threshold: f64,
    /// Exit threshold (typically -100)
    exit_threshold: f64,
}

impl CCIStrategy {
    pub fn new(period: usize, entry_threshold: f64, exit_threshold: f64) -> Self {
        assert!(period > 0, "Period must be at least 1");
        assert!(
            entry_threshold > exit_threshold,
            "Entry threshold must be greater than exit threshold"
        );

        Self {
            period,
            entry_threshold,
            exit_threshold,
        }
    }

    /// Standard configuration: period 20, +100/-100
    pub fn standard() -> Self {
        Self::new(20, 100.0, -100.0)
    }

    /// Fast configuration: period 14, +100/-100
    pub fn fast() -> Self {
        Self::new(14, 100.0, -100.0)
    }

    /// Conservative configuration: period 40, +150/-150
    pub fn conservative() -> Self {
        Self::new(40, 150.0, -150.0)
    }

    /// Get the period.
    pub fn period(&self) -> usize {
        self.period
    }

    /// Get the entry threshold.
    pub fn entry_threshold(&self) -> f64 {
        self.entry_threshold
    }

    /// Get the exit threshold.
    pub fn exit_threshold(&self) -> f64 {
        self.exit_threshold
    }
}

impl Strategy for CCIStrategy {
    fn id(&self) -> &str {
        "cci"
    }

    fn warmup_period(&self) -> usize {
        self.period
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let cci_values = cci(bars, self.period);

        // Get current and previous CCI values
        let current_cci = match cci_values[current_idx] {
            Some(ref c) => c.cci,
            None => return Signal::Hold,
        };

        // Need previous bar for crossover detection
        if current_idx == 0 {
            return Signal::Hold;
        }

        let prev_cci = match cci_values[current_idx - 1] {
            Some(ref c) => c.cci,
            None => return Signal::Hold,
        };

        match current_position {
            Position::Flat => {
                // Entry: CCI crosses above entry threshold
                if current_cci > self.entry_threshold && prev_cci <= self.entry_threshold {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: CCI crosses below exit threshold
                if current_cci < self.exit_threshold && prev_cci >= self.exit_threshold {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {}
}

/// ROC (Rate of Change) Strategy.
///
/// Entry: ROC crosses above 0 (positive momentum)
/// Exit: ROC crosses below 0 (negative momentum)
///
/// ROC measures the percentage change between the current price
/// and the price N periods ago. It's a simple momentum indicator.
///
/// Common configurations:
/// - Period 12: Standard monthly momentum
/// - Period 9: Faster signals
/// - Period 25: Slower, fewer signals
#[derive(Debug, Clone)]
pub struct ROCStrategy {
    /// Period for ROC calculation
    period: usize,
}

impl ROCStrategy {
    pub fn new(period: usize) -> Self {
        assert!(period > 0, "Period must be at least 1");

        Self { period }
    }

    /// Standard configuration: period 12
    pub fn standard() -> Self {
        Self::new(12)
    }

    /// Fast configuration: period 9
    pub fn fast() -> Self {
        Self::new(9)
    }

    /// Slow configuration: period 25
    pub fn slow() -> Self {
        Self::new(25)
    }

    /// Get the period.
    pub fn period(&self) -> usize {
        self.period
    }
}

impl Strategy for ROCStrategy {
    fn id(&self) -> &str {
        "roc"
    }

    fn warmup_period(&self) -> usize {
        self.period
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let roc_values = roc(bars, self.period);

        // Get current and previous ROC values
        let current_roc = match roc_values[current_idx] {
            Some(ref r) => r.roc,
            None => return Signal::Hold,
        };

        // Need previous bar for crossover detection
        if current_idx == 0 {
            return Signal::Hold;
        }

        let prev_roc = match roc_values[current_idx - 1] {
            Some(ref r) => r.roc,
            None => return Signal::Hold,
        };

        match current_position {
            Position::Flat => {
                // Entry: ROC crosses above 0
                if current_roc > 0.0 && prev_roc <= 0.0 {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: ROC crosses below 0
                if current_roc < 0.0 && prev_roc >= 0.0 {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {}
}

// =============================================================================
// Phase 5b: Hybrid/Confluence Strategies
// =============================================================================

/// RSI + Bollinger Bands Hybrid Strategy.
///
/// Entry: RSI < oversold threshold AND close touches/breaks lower Bollinger Band
/// Exit: Close crosses above middle band (SMA) OR RSI > exit_rsi threshold
///
/// This strategy combines mean reversion (RSI oversold) with volatility bands
/// to identify high-probability reversal points.
///
/// Common configurations:
/// - RSI 14/30, BB 20/2.0, Exit RSI 50: Standard
/// - RSI 7/20, BB 20/2.5, Exit RSI 50: More aggressive entries
#[derive(Debug, Clone)]
pub struct RSIBollingerStrategy {
    /// RSI period
    rsi_period: usize,
    /// RSI oversold threshold for entry
    rsi_oversold: f64,
    /// RSI level for exit (typically neutral)
    rsi_exit: f64,
    /// Bollinger Bands period
    bb_period: usize,
    /// Bollinger Bands standard deviation multiplier
    bb_std_mult: f64,
}

impl RSIBollingerStrategy {
    pub fn new(
        rsi_period: usize,
        rsi_oversold: f64,
        rsi_exit: f64,
        bb_period: usize,
        bb_std_mult: f64,
    ) -> Self {
        assert!(rsi_period > 0, "RSI period must be at least 1");
        assert!(
            rsi_oversold > 0.0 && rsi_oversold < 100.0,
            "RSI oversold must be between 0 and 100"
        );
        assert!(
            rsi_exit > rsi_oversold,
            "RSI exit must be greater than oversold"
        );
        assert!(bb_period > 0, "BB period must be at least 1");
        assert!(bb_std_mult > 0.0, "BB std mult must be positive");

        Self {
            rsi_period,
            rsi_oversold,
            rsi_exit,
            bb_period,
            bb_std_mult,
        }
    }

    /// Standard configuration: RSI 14/30/50, BB 20/2.0
    pub fn standard() -> Self {
        Self::new(14, 30.0, 50.0, 20, 2.0)
    }

    /// Aggressive configuration: RSI 7/20/50, BB 20/2.5
    pub fn aggressive() -> Self {
        Self::new(7, 20.0, 50.0, 20, 2.5)
    }

    /// Get the RSI period.
    pub fn rsi_period(&self) -> usize {
        self.rsi_period
    }

    /// Get the RSI oversold threshold.
    pub fn rsi_oversold(&self) -> f64 {
        self.rsi_oversold
    }

    /// Get the RSI exit threshold.
    pub fn rsi_exit(&self) -> f64 {
        self.rsi_exit
    }

    /// Get the Bollinger Bands period.
    pub fn bb_period(&self) -> usize {
        self.bb_period
    }

    /// Get the Bollinger Bands std multiplier.
    pub fn bb_std_mult(&self) -> f64 {
        self.bb_std_mult
    }
}

impl Strategy for RSIBollingerStrategy {
    fn id(&self) -> &str {
        "rsi_bollinger"
    }

    fn warmup_period(&self) -> usize {
        // Max of RSI and BB warmup periods
        (self.rsi_period + 1).max(self.bb_period)
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let rsi_values = rsi(bars, self.rsi_period);
        let bb_values = bollinger_bands(bars, self.bb_period, self.bb_std_mult);

        // Get current values
        let current_rsi = match rsi_values[current_idx] {
            Some(ref r) => r.rsi,
            None => return Signal::Hold,
        };

        let current_bb = match bb_values[current_idx] {
            Some(ref b) => b,
            None => return Signal::Hold,
        };

        let current_close = bars[current_idx].close;

        match current_position {
            Position::Flat => {
                // Entry: RSI < oversold AND close <= lower BB
                if current_rsi < self.rsi_oversold && current_close <= current_bb.lower {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: Close > middle band OR RSI > exit threshold
                if current_close > current_bb.middle || current_rsi > self.rsi_exit {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {}
}

/// MACD + ADX Filter Strategy.
///
/// Entry: MACD crosses above signal line AND ADX > threshold
/// Exit: MACD crosses below signal line
///
/// This strategy combines MACD momentum signals with ADX trend strength
/// filter to avoid false signals in ranging markets.
///
/// Common configurations:
/// - MACD 12/26/9, ADX 14/25: Standard
/// - MACD 8/17/9, ADX 14/20: Faster with lower ADX threshold
#[derive(Debug, Clone)]
pub struct MACDAdxStrategy {
    /// MACD fast period
    fast_period: usize,
    /// MACD slow period
    slow_period: usize,
    /// MACD signal period
    signal_period: usize,
    /// ADX period
    adx_period: usize,
    /// ADX threshold for trend strength
    adx_threshold: f64,
}

impl MACDAdxStrategy {
    pub fn new(
        fast_period: usize,
        slow_period: usize,
        signal_period: usize,
        adx_period: usize,
        adx_threshold: f64,
    ) -> Self {
        assert!(fast_period > 0, "Fast period must be at least 1");
        assert!(
            slow_period > fast_period,
            "Slow period must be greater than fast period"
        );
        assert!(signal_period > 0, "Signal period must be at least 1");
        assert!(adx_period > 0, "ADX period must be at least 1");
        assert!(adx_threshold > 0.0, "ADX threshold must be positive");

        Self {
            fast_period,
            slow_period,
            signal_period,
            adx_period,
            adx_threshold,
        }
    }

    /// Standard configuration: MACD 12/26/9, ADX 14/25
    pub fn standard() -> Self {
        Self::new(12, 26, 9, 14, 25.0)
    }

    /// Fast configuration: MACD 8/17/9, ADX 14/20
    pub fn fast() -> Self {
        Self::new(8, 17, 9, 14, 20.0)
    }

    /// Get the MACD fast period.
    pub fn fast_period(&self) -> usize {
        self.fast_period
    }

    /// Get the MACD slow period.
    pub fn slow_period(&self) -> usize {
        self.slow_period
    }

    /// Get the MACD signal period.
    pub fn signal_period(&self) -> usize {
        self.signal_period
    }

    /// Get the ADX period.
    pub fn adx_period(&self) -> usize {
        self.adx_period
    }

    /// Get the ADX threshold.
    pub fn adx_threshold(&self) -> f64 {
        self.adx_threshold
    }
}

impl Strategy for MACDAdxStrategy {
    fn id(&self) -> &str {
        "macd_adx"
    }

    fn warmup_period(&self) -> usize {
        // Max of MACD and ADX warmup periods
        let macd_warmup = self.slow_period + self.signal_period;
        let adx_warmup = 2 * self.adx_period; // ADX needs double smoothing
        macd_warmup.max(adx_warmup)
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let macd_values = macd(bars, self.fast_period, self.slow_period, self.signal_period);
        let dmi_values = dmi(bars, self.adx_period);

        // Get current and previous MACD values
        let current_macd = match macd_values[current_idx] {
            Some(ref m) => m,
            None => return Signal::Hold,
        };

        let current_dmi = match dmi_values[current_idx] {
            Some(ref d) => d,
            None => return Signal::Hold,
        };

        // Need previous bar for crossover detection
        if current_idx == 0 {
            return Signal::Hold;
        }

        let prev_macd = match macd_values[current_idx - 1] {
            Some(ref m) => m,
            None => return Signal::Hold,
        };

        let macd_above_signal = current_macd.macd_line > current_macd.signal_line;
        let prev_macd_above_signal = prev_macd.macd_line > prev_macd.signal_line;
        let strong_trend = current_dmi.adx > self.adx_threshold;

        match current_position {
            Position::Flat => {
                // Entry: MACD crosses above signal AND ADX > threshold
                if macd_above_signal && !prev_macd_above_signal && strong_trend {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: MACD crosses below signal line
                if !macd_above_signal && prev_macd_above_signal {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {}
}

/// Multi-Oscillator Confluence Strategy.
///
/// Entry: Both RSI shows bullish crossover AND Stochastic %K > %D
/// Exit: Either RSI shows bearish crossover OR Stochastic %K < %D
///
/// This strategy requires agreement between two oscillators for entry,
/// but only one needs to signal for exit (conservative exit).
///
/// Common configurations:
/// - RSI 14/30/70, Stoch 14/3/3/20/80: Standard
#[derive(Debug, Clone)]
pub struct OscillatorConfluenceStrategy {
    /// RSI period
    rsi_period: usize,
    /// RSI oversold threshold
    rsi_oversold: f64,
    /// RSI overbought threshold
    rsi_overbought: f64,
    /// Stochastic K period
    stoch_k_period: usize,
    /// Stochastic K smoothing
    stoch_k_smooth: usize,
    /// Stochastic D period
    stoch_d_period: usize,
    /// Stochastic oversold threshold (reserved for future use)
    #[allow(dead_code)]
    stoch_oversold: f64,
    /// Stochastic overbought threshold (reserved for future use)
    #[allow(dead_code)]
    stoch_overbought: f64,
}

impl OscillatorConfluenceStrategy {
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        rsi_period: usize,
        rsi_oversold: f64,
        rsi_overbought: f64,
        stoch_k_period: usize,
        stoch_k_smooth: usize,
        stoch_d_period: usize,
        stoch_oversold: f64,
        stoch_overbought: f64,
    ) -> Self {
        assert!(rsi_period > 0, "RSI period must be at least 1");
        assert!(
            rsi_oversold < rsi_overbought,
            "RSI oversold must be less than overbought"
        );
        assert!(stoch_k_period > 0, "Stoch K period must be at least 1");
        assert!(
            stoch_oversold < stoch_overbought,
            "Stoch oversold must be less than overbought"
        );

        Self {
            rsi_period,
            rsi_oversold,
            rsi_overbought,
            stoch_k_period,
            stoch_k_smooth,
            stoch_d_period,
            stoch_oversold,
            stoch_overbought,
        }
    }

    /// Standard configuration
    pub fn standard() -> Self {
        Self::new(14, 30.0, 70.0, 14, 3, 3, 20.0, 80.0)
    }

    /// Get the RSI period.
    pub fn rsi_period(&self) -> usize {
        self.rsi_period
    }

    /// Get the Stochastic K period.
    pub fn stoch_k_period(&self) -> usize {
        self.stoch_k_period
    }
}

impl Strategy for OscillatorConfluenceStrategy {
    fn id(&self) -> &str {
        "oscillator_confluence"
    }

    fn warmup_period(&self) -> usize {
        let rsi_warmup = self.rsi_period + 1;
        let stoch_warmup = self.stoch_k_period + self.stoch_k_smooth + self.stoch_d_period;
        rsi_warmup.max(stoch_warmup)
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let rsi_values = rsi(bars, self.rsi_period);
        let stoch_values = stochastic(
            bars,
            self.stoch_k_period,
            self.stoch_k_smooth,
            self.stoch_d_period,
        );

        // Get current and previous values
        let current_rsi = match rsi_values[current_idx] {
            Some(ref r) => r.rsi,
            None => return Signal::Hold,
        };

        let current_stoch = match stoch_values[current_idx] {
            Some(ref s) => s,
            None => return Signal::Hold,
        };

        // Need previous bar for crossover detection
        if current_idx == 0 {
            return Signal::Hold;
        }

        let prev_rsi = match rsi_values[current_idx - 1] {
            Some(ref r) => r.rsi,
            None => return Signal::Hold,
        };

        let prev_stoch = match stoch_values[current_idx - 1] {
            Some(ref s) => s,
            None => return Signal::Hold,
        };

        // RSI crossover detection
        let rsi_bullish_cross = current_rsi > self.rsi_oversold && prev_rsi <= self.rsi_oversold;
        let rsi_bearish_cross =
            current_rsi < self.rsi_overbought && prev_rsi >= self.rsi_overbought;

        // Stochastic state
        let stoch_bullish = current_stoch.k_smooth > current_stoch.d;
        let stoch_bearish = current_stoch.k_smooth < current_stoch.d;
        let prev_stoch_bullish = prev_stoch.k_smooth > prev_stoch.d;

        match current_position {
            Position::Flat => {
                // Entry: RSI bullish crossover AND Stochastic K > D
                if rsi_bullish_cross && stoch_bullish {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: RSI bearish crossover OR Stochastic K crosses below D
                let stoch_bearish_cross = stoch_bearish && prev_stoch_bullish;
                if rsi_bearish_cross || stoch_bearish_cross {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {}
}

/// Ichimoku Cloud Strategy.
///
/// Entry: Price above cloud AND Tenkan-sen crosses above Kijun-sen
/// Exit: Price below cloud OR Tenkan-sen crosses below Kijun-sen
///
/// The Ichimoku Kinko Hyo ("one glance equilibrium chart") is a comprehensive
/// indicator that defines support/resistance, trend direction, and momentum.
///
/// Components:
/// - Tenkan-sen (conversion line): (9-period high + 9-period low) / 2
/// - Kijun-sen (base line): (26-period high + 26-period low) / 2
/// - Senkou Span A (leading span A): (Tenkan + Kijun) / 2, shifted 26 periods ahead
/// - Senkou Span B (leading span B): (52-period high + 52-period low) / 2, shifted 26 periods ahead
/// - Kumo (cloud): Area between Senkou Span A and B
///
/// Common configurations:
/// - 9/26/52: Standard (traditional Japanese trading week settings)
/// - 7/22/44: Adapted for crypto/24-7 markets
#[derive(Debug, Clone)]
pub struct IchimokuStrategy {
    /// Tenkan-sen period (conversion line)
    tenkan_period: usize,
    /// Kijun-sen period (base line)
    kijun_period: usize,
    /// Senkou Span B period
    senkou_b_period: usize,
}

impl IchimokuStrategy {
    pub fn new(tenkan_period: usize, kijun_period: usize, senkou_b_period: usize) -> Self {
        assert!(tenkan_period > 0, "Tenkan period must be at least 1");
        assert!(kijun_period > 0, "Kijun period must be at least 1");
        assert!(senkou_b_period > 0, "Senkou B period must be at least 1");
        assert!(
            tenkan_period < kijun_period,
            "Tenkan period should be less than Kijun period"
        );

        Self {
            tenkan_period,
            kijun_period,
            senkou_b_period,
        }
    }

    /// Standard configuration: 9/26/52
    pub fn standard() -> Self {
        Self::new(9, 26, 52)
    }

    /// Crypto/fast configuration: 7/22/44
    pub fn crypto() -> Self {
        Self::new(7, 22, 44)
    }

    /// Double configuration: 18/52/104
    pub fn double() -> Self {
        Self::new(18, 52, 104)
    }

    /// Get the Tenkan-sen period.
    pub fn tenkan_period(&self) -> usize {
        self.tenkan_period
    }

    /// Get the Kijun-sen period.
    pub fn kijun_period(&self) -> usize {
        self.kijun_period
    }

    /// Get the Senkou Span B period.
    pub fn senkou_b_period(&self) -> usize {
        self.senkou_b_period
    }
}

impl Strategy for IchimokuStrategy {
    fn id(&self) -> &str {
        "ichimoku"
    }

    fn warmup_period(&self) -> usize {
        // Need the longest period (Senkou B) plus displacement (Kijun period)
        self.senkou_b_period + self.kijun_period
    }

    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal {
        if bars.is_empty() {
            return Signal::Hold;
        }

        let current_idx = bars.len() - 1;

        // During warmup, no signals
        if current_idx < self.warmup_period() {
            return Signal::Hold;
        }

        let ichimoku_values = ichimoku(
            bars,
            self.tenkan_period,
            self.kijun_period,
            self.senkou_b_period,
        );

        // Get current and previous Ichimoku values
        let current_ich = match ichimoku_values[current_idx] {
            Some(ref i) => i,
            None => return Signal::Hold,
        };

        // Need previous bar for crossover detection
        if current_idx == 0 {
            return Signal::Hold;
        }

        let prev_ich = match ichimoku_values[current_idx - 1] {
            Some(ref i) => i,
            None => return Signal::Hold,
        };

        let current_close = bars[current_idx].close;

        // Determine cloud bounds (cloud is between Senkou Span A and B)
        let cloud_top = current_ich.senkou_span_a.max(current_ich.senkou_span_b);
        let cloud_bottom = current_ich.senkou_span_a.min(current_ich.senkou_span_b);

        // Price position relative to cloud
        let price_above_cloud = current_close > cloud_top;
        let price_below_cloud = current_close < cloud_bottom;

        // Tenkan/Kijun crossover
        let tenkan_above_kijun = current_ich.tenkan_sen > current_ich.kijun_sen;
        let prev_tenkan_above_kijun = prev_ich.tenkan_sen > prev_ich.kijun_sen;

        match current_position {
            Position::Flat => {
                // Entry: Price above cloud AND Tenkan crosses above Kijun
                if price_above_cloud && tenkan_above_kijun && !prev_tenkan_above_kijun {
                    return Signal::EnterLong;
                }
                Signal::Hold
            }
            Position::Long => {
                // Exit: Price below cloud OR Tenkan crosses below Kijun
                let tenkan_bearish_cross = !tenkan_above_kijun && prev_tenkan_above_kijun;
                if price_below_cloud || tenkan_bearish_cross {
                    return Signal::ExitLong;
                }
                Signal::Hold
            }
            Position::Short => Signal::Hold,
        }
    }

    fn reset(&mut self) {}
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::TimeZone;

    fn make_bar(day: u32, open: f64, high: f64, low: f64, close: f64) -> Bar {
        let ts = chrono::Utc.with_ymd_and_hms(2024, 1, day, 0, 0, 0).unwrap();
        Bar::new(ts, open, high, low, close, 1000.0, "TEST", "1d")
    }

    #[test]
    fn test_null_strategy() {
        let strategy = NullStrategy;
        assert_eq!(strategy.id(), "null");
        assert_eq!(strategy.warmup_period(), 0);
        assert_eq!(strategy.signal(&[], Position::Flat), Signal::Hold);
    }

    #[test]
    fn test_donchian_uptrend_generates_entry() {
        // Create a clear uptrend: price goes from 100 to 120 over 15 bars
        let bars: Vec<Bar> = (1..=15)
            .map(|i| {
                let base = 100.0 + (i as f64) * 1.5;
                make_bar(i as u32, base, base + 1.0, base - 0.5, base + 0.5)
            })
            .collect();

        // Use lookback of 10
        let strategy = DonchianBreakoutStrategy::new(10, 5);

        // After warmup (10 bars), strategy should signal entry on continued uptrend
        // At bar 11 (index 10): close should be above prior 10-day high
        let signal = strategy.signal(&bars[..11], Position::Flat);

        // Bar 10 close = 100 + 11*1.5 + 0.5 = 117.0
        // Prior 10 bars (0-9) highest high = bar 9 high = 100 + 10*1.5 + 1.0 = 116.0
        // Entry condition: 117.0 > 116.0  true!
        assert_eq!(
            signal,
            Signal::EnterLong,
            "Strategy should enter on uptrend breakout"
        );
    }

    #[test]
    fn test_donchian_during_warmup_holds() {
        let bars: Vec<Bar> = (1..=10)
            .map(|i| {
                let base = 100.0 + (i as f64);
                make_bar(i as u32, base, base + 1.0, base - 0.5, base + 0.5)
            })
            .collect();

        let strategy = DonchianBreakoutStrategy::new(10, 5);

        // During warmup, should always hold
        for i in 1..=10 {
            let signal = strategy.signal(&bars[..i], Position::Flat);
            assert_eq!(
                signal,
                Signal::Hold,
                "Should hold during warmup at bar {}",
                i
            );
        }
    }

    #[test]
    fn test_donchian_exit_on_downtrend() {
        // First, create uptrend then reversal
        let mut bars: Vec<Bar> = (1..=15)
            .map(|i| {
                let base = 100.0 + (i as f64) * 1.5;
                make_bar(i as u32, base, base + 1.0, base - 0.5, base + 0.5)
            })
            .collect();

        // Add bars that go down to trigger exit (5-day exit lookback)
        for i in 16..=22 {
            let base = 120.0 - ((i - 15) as f64) * 3.0;
            bars.push(make_bar(i as u32, base, base + 0.5, base - 1.0, base - 0.5));
        }

        let strategy = DonchianBreakoutStrategy::new(10, 5);

        // Check that exit triggers when close < 5-day low
        // At bar 20 (after 5 bars of decline), close should be below prior 5-day low
        let signal = strategy.signal(&bars[..20], Position::Long);

        // Bar 20 close should be below prior 5-day low
        // This should trigger an exit
        assert_eq!(
            signal,
            Signal::ExitLong,
            "Strategy should exit on downtrend"
        );
    }
}
