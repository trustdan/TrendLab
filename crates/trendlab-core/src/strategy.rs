//! Strategy trait and common implementations.

use crate::bar::Bar;

/// Position state in a backtest.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Position {
    Flat,
    Long,
    // Short will be added in Phase 2
}

/// Signal generated by a strategy.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Signal {
    /// No action
    Hold,
    /// Enter long position
    EnterLong,
    /// Exit long position
    ExitLong,
}

/// Trait for trend-following strategies.
///
/// Strategies compute signals based on historical bar data.
/// The signal at bar T can only use data from bars 0..=T (no lookahead).
pub trait Strategy: Send + Sync {
    /// Returns the strategy's unique identifier.
    fn id(&self) -> &str;

    /// Returns the minimum number of bars required before generating signals.
    fn warmup_period(&self) -> usize;

    /// Compute signal for the current bar.
    ///
    /// # Arguments
    /// * `bars` - Historical bars up to and including current bar
    /// * `current_position` - Current position state
    ///
    /// # Returns
    /// Signal indicating what action to take
    fn signal(&self, bars: &[Bar], current_position: Position) -> Signal;

    /// Reset internal state (for running multiple backtests).
    fn reset(&mut self);
}

/// Placeholder strategy that never trades.
#[derive(Debug, Default)]
pub struct NullStrategy;

impl Strategy for NullStrategy {
    fn id(&self) -> &str {
        "null"
    }

    fn warmup_period(&self) -> usize {
        0
    }

    fn signal(&self, _bars: &[Bar], _current_position: Position) -> Signal {
        Signal::Hold
    }

    fn reset(&mut self) {}
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_null_strategy() {
        let strategy = NullStrategy;
        assert_eq!(strategy.id(), "null");
        assert_eq!(strategy.warmup_period(), 0);
        assert_eq!(strategy.signal(&[], Position::Flat), Signal::Hold);
    }
}
